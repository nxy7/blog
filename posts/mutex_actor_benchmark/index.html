<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Rust - Mutex vs Actor benchmark | just some developer thoughts</title><meta name=keywords content><meta name=description content="Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment. All code for this benchmark is available in (my github repo)[https://github.com/nxy7/rs-actor-mutex-benchmark], but I&rsquo;ve decided to copy some parts of implementation here.
Actor implementation #[derive(Default)] pub struct BenchActor { count: i64, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option<oneshot::Sender<()>>, } pub enum Message { IncreaseBySync(i64, oneshot::Sender<()>), DecreaseBySync(i64, oneshot::Sender<()>), IncreaseBy(i64), DecreaseBy(i64), Get(oneshot::Sender<i64>), } impl BenchActor { pub fn new(m: oneshot::Sender<()>) -> Self { Self { tx: Some(m), ."><meta name=author content><link rel=canonical href=https://nxyt.pl/blog/posts/mutex_actor_benchmark/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nxyt.pl/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nxyt.pl/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nxyt.pl/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://nxyt.pl/blog/apple-touch-icon.png><link rel=mask-icon href=https://nxyt.pl/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script><meta property="og:title" content="Rust - Mutex vs Actor benchmark"><meta property="og:description" content="Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment. All code for this benchmark is available in (my github repo)[https://github.com/nxy7/rs-actor-mutex-benchmark], but I&rsquo;ve decided to copy some parts of implementation here.
Actor implementation #[derive(Default)] pub struct BenchActor { count: i64, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option<oneshot::Sender<()>>, } pub enum Message { IncreaseBySync(i64, oneshot::Sender<()>), DecreaseBySync(i64, oneshot::Sender<()>), IncreaseBy(i64), DecreaseBy(i64), Get(oneshot::Sender<i64>), } impl BenchActor { pub fn new(m: oneshot::Sender<()>) -> Self { Self { tx: Some(m), ."><meta property="og:type" content="article"><meta property="og:url" content="https://nxyt.pl/blog/posts/mutex_actor_benchmark/"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rust - Mutex vs Actor benchmark"><meta name=twitter:description content="Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment. All code for this benchmark is available in (my github repo)[https://github.com/nxy7/rs-actor-mutex-benchmark], but I&rsquo;ve decided to copy some parts of implementation here.
Actor implementation #[derive(Default)] pub struct BenchActor { count: i64, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option<oneshot::Sender<()>>, } pub enum Message { IncreaseBySync(i64, oneshot::Sender<()>), DecreaseBySync(i64, oneshot::Sender<()>), IncreaseBy(i64), DecreaseBy(i64), Get(oneshot::Sender<i64>), } impl BenchActor { pub fn new(m: oneshot::Sender<()>) -> Self { Self { tx: Some(m), ."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nxyt.pl/blog/posts/"},{"@type":"ListItem","position":3,"name":"Rust - Mutex vs Actor benchmark","item":"https://nxyt.pl/blog/posts/mutex_actor_benchmark/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Rust - Mutex vs Actor benchmark","name":"Rust - Mutex vs Actor benchmark","description":"Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment. All code for this benchmark is available in (my github repo)[https://github.com/nxy7/rs-actor-mutex-benchmark], but I\u0026rsquo;ve decided to copy some parts of implementation here.\nActor implementation #[derive(Default)] pub struct BenchActor { count: i64, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option\u0026lt;oneshot::Sender\u0026lt;()\u0026gt;\u0026gt;, } pub enum Message { IncreaseBySync(i64, oneshot::Sender\u0026lt;()\u0026gt;), DecreaseBySync(i64, oneshot::Sender\u0026lt;()\u0026gt;), IncreaseBy(i64), DecreaseBy(i64), Get(oneshot::Sender\u0026lt;i64\u0026gt;), } impl BenchActor { pub fn new(m: oneshot::Sender\u0026lt;()\u0026gt;) -\u0026gt; Self { Self { tx: Some(m), .","keywords":[],"articleBody":"Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment. All code for this benchmark is available in (my github repo)[https://github.com/nxy7/rs-actor-mutex-benchmark], but I’ve decided to copy some parts of implementation here.\nActor implementation #[derive(Default)] pub struct BenchActor { count: i64, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option\u003coneshot::Sender\u003c()\u003e\u003e, } pub enum Message { IncreaseBySync(i64, oneshot::Sender\u003c()\u003e), DecreaseBySync(i64, oneshot::Sender\u003c()\u003e), IncreaseBy(i64), DecreaseBy(i64), Get(oneshot::Sender\u003ci64\u003e), } impl BenchActor { pub fn new(m: oneshot::Sender\u003c()\u003e) -\u003e Self { Self { tx: Some(m), ..Default::default() } } pub async fn start(mut self) -\u003e Sender\u003cMessage\u003e { let (tx, mut rx) = mpsc::channel(10000); tokio::spawn(async move { while let Some(m) = rx.recv().await { match m { Message::IncreaseBySync(i, r) =\u003e { self.count += i; r.send(()).unwrap(); } Message::DecreaseBySync(i, r) =\u003e { self.count -= i; r.send(()).unwrap(); } Message::Get(r) =\u003e { r.send(self.count).unwrap(); } Message::IncreaseBy(i) =\u003e { self.count += i; if self.count == REACHED_COUNT_SIGNAL_AMOUNT { if let Some(tx) = self.tx { tx.send(()).unwrap(); break; } } } Message::DecreaseBy(i) =\u003e { self.count -= i; if self.count == REACHED_COUNT_SIGNAL_AMOUNT { if let Some(tx) = self.tx { tx.send(()).unwrap(); break; } } } } } }); tx } } This actor implementation is very simple, but does what Actor should do - it limits access to inner values to just one thread. Beside that it doesn’t do any work it doesn’t have to, one inefficiency I’ve had to resort to was checking count in methods that don’t return any values, so I know when to finish benchmark iteration. The most time consuming thing in this implementation is sending values over channels - something that you cannot avoid in Actor model.\nMutex implementation #[derive(Default)] pub struct BenchMutex { count: Mutex\u003ci64\u003e, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option\u003cmpsc::Sender\u003c()\u003e\u003e, } impl BenchMutex { pub fn new(m: mpsc::Sender\u003c()\u003e) -\u003e Self { Self { tx: Some(m), ..Default::default() } } pub async fn increase_by(\u0026self, i: i64) { (*self.count.lock().await) += i; } pub async fn decrease_by(\u0026self, i: i64) { (*self.count.lock().await) -= i; } pub async fn increase_by_checked(\u0026self, i: i64) { let mut v = self.count.lock().await; *v += i; if *v == REACHED_COUNT_SIGNAL_AMOUNT { if let Some(tx) = self.tx.clone() { tx.send(()).await; } } } pub async fn decrease_by_checked(\u0026self, i: i64) { let mut v = self.count.lock().await; *v -= i; if *v == REACHED_COUNT_SIGNAL_AMOUNT { if let Some(tx) = self.tx.clone() { tx.send(()).await; } } } pub async fn get(\u0026self) -\u003e i64 { *self.count.lock().await } } Again - very simple struct. I’ve added _checked methods and made them do the same extra work that Actor had to do to know when to stop bench iteration. I was a little worried that this small value check might in fact slow Mutex because I was holding the lock longer than I had to, but that didn’t turn out to be true.\nMutex vs Actor benchmark Mutex vs Actor that returns values Results mutex vs actor/mutex time: [1.4809 ms 1.4839 ms 1.4872 ms] change: [+288.15% +290.30% +292.68%] (p = 0.00 \u003c 0.05) Performance has regressed. Found 9 outliers among 100 measurements (9.00%) 5 (5.00%) high mild 4 (4.00%) high severe mutex vs actor/actor time: [4.5462 ms 4.5587 ms 4.5713 ms] change: [-96.680% -96.664% -96.648%] (p = 0.00 \u003c 0.05) Performance has improved. Found 5 outliers among 100 measurements (5.00%) 1 (1.00%) low mild 2 (2.00%) high mild 2 (2.00%) high severe As you can see Mutex version turned out 3x faster. It doesn’t really surprise me because this actor implementation was returning values over oneshot channel, which is something that you might sometimes want, but I’m sure it slows it down significantly. I’ve mainly decided to make actor return values because it made for easier benchmark setup. It’s good to know though how much slower is returning values over channel vs memory access. This benchmark results should apply to all actor methods that modify state and want to know new value instantly.\nMutex vs Actor that don’t have to return values Results mutex vs actor 'async'/mutex time: [1.3995 ms 1.4029 ms 1.4067 ms] change: [+17.433% +17.905% +18.354%] (p = 0.00 \u003c 0.05) mutex vs actor 'async'/actor time: [2.7879 ms 2.7944 ms 2.8008 ms] change: [+48.814% +49.399% +49.947%] (p = 0.00 \u003c 0.05) I’ve added ‘async’ version of the benchmark. ‘Async’ here means that caller of actor doesn’t want to get values back, so he’s essentially just sending Message over channel and leaves. This required additional check to know when Actor received all messages. To keep both implementations the same I’ve made Mutex also do the same equality check thinking that it would significantly increase bench time for Mutex, but to my surprise the equality check was so fast, that it didn’t make any difference in Mutex time. There was a difference for Actor implementation - without the need to send return signal on each Message Actors became ~40% faster. They’re still 2x slower than Mutexes though.\nHigher concurrency In first set of benchmarks I was spawning 10000 futures per bench iteration. I’ve decided to see what happens if I increase it by x10. Is the time going to change linearly for both implementations or are Mutexes going to suffer because they have to fight for each lock?\nResults mutex vs actor 'sync'/mutex time: [16.629 ms 16.762 ms 16.908 ms] change: [+11058% +11156% +11266%] (p = 0.00 \u003c 0.05) mutex vs actor 'sync'/actor time: [48.231 ms 48.551 ms 48.909 ms] change: [+9403.5% +9498.0% +9591.7%] (p = 0.00 \u003c 0.05) mutex vs actor 'async'/mutex time: [16.613 ms 16.667 ms 16.730 ms] change: [+1081.8% +1086.4% +1091.2%] (p = 0.00 \u003c 0.05) mutex vs actor 'async'/actor time: [32.053 ms 32.181 ms 32.353 ms] change: [+1047.2% +1052.8% +1059.3%] (p = 0.00 \u003c 0.05) So that didn’t really happen. Mutexes are still 2x faster than actors that don’t return values and 3x faster than actors that return values. I think that actors can make some designs simpler and mutexes can be hard to use, but when it comes to performance it seems that Mutexes are clear winner.\nThis test was very simple - it was just ‘dumb’ value access and modification, but I still find the results interesting and hopefully one of you did as well.\n","wordCount":"1027","inLanguage":"en","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://nxyt.pl/blog/posts/mutex_actor_benchmark/"},"publisher":{"@type":"Organization","name":"just some developer thoughts","logo":{"@type":"ImageObject","url":"https://nxyt.pl/blog/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nxyt.pl/blog accesskey=h title="just some developer thoughts (Alt + H)">just some developer thoughts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Rust - Mutex vs Actor benchmark</h1><div class=post-meta></div></header><div class=post-content><p>Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment.
All code for this benchmark is available in (my github repo)[https://github.com/nxy7/rs-actor-mutex-benchmark], but I&rsquo;ve decided to copy some parts of
implementation here.</p><h1 id=actor-implementation>Actor implementation<a hidden class=anchor aria-hidden=true href=#actor-implementation>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span>  <span style=color:#75715e>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BenchActor</span> {
</span></span><span style=display:flex><span>    count: <span style=color:#66d9ef>i64</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    tx: Option<span style=color:#f92672>&lt;</span>oneshot::Sender<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Message</span> {
</span></span><span style=display:flex><span>    IncreaseBySync(<span style=color:#66d9ef>i64</span>, oneshot::Sender<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    DecreaseBySync(<span style=color:#66d9ef>i64</span>, oneshot::Sender<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>    IncreaseBy(<span style=color:#66d9ef>i64</span>),
</span></span><span style=display:flex><span>    DecreaseBy(<span style=color:#66d9ef>i64</span>),
</span></span><span style=display:flex><span>    Get(oneshot::Sender<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> BenchActor {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(m: <span style=color:#a6e22e>oneshot</span>::Sender<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            tx: Some(m),
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>Default::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>start</span>(<span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#a6e22e>Sender</span><span style=color:#f92672>&lt;</span>Message<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> (tx, <span style=color:#66d9ef>mut</span> rx) <span style=color:#f92672>=</span> mpsc::channel(<span style=color:#ae81ff>10000</span>);
</span></span><span style=display:flex><span>        tokio::spawn(<span style=color:#66d9ef>async</span> <span style=color:#66d9ef>move</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> <span style=color:#66d9ef>let</span> Some(m) <span style=color:#f92672>=</span> rx.recv().<span style=color:#66d9ef>await</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>match</span> m {
</span></span><span style=display:flex><span>                    Message::IncreaseBySync(i, r) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        self.count <span style=color:#f92672>+=</span> i;
</span></span><span style=display:flex><span>                        r.send(()).unwrap();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Message::DecreaseBySync(i, r) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        self.count <span style=color:#f92672>-=</span> i;
</span></span><span style=display:flex><span>                        r.send(()).unwrap();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Message::Get(r) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        r.send(self.count).unwrap();
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Message::IncreaseBy(i) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        self.count <span style=color:#f92672>+=</span> i;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> self.count <span style=color:#f92672>==</span> REACHED_COUNT_SIGNAL_AMOUNT {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(tx) <span style=color:#f92672>=</span> self.tx {
</span></span><span style=display:flex><span>                                tx.send(()).unwrap();
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                    Message::DecreaseBy(i) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>                        self.count <span style=color:#f92672>-=</span> i;
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>if</span> self.count <span style=color:#f92672>==</span> REACHED_COUNT_SIGNAL_AMOUNT {
</span></span><span style=display:flex><span>                            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(tx) <span style=color:#f92672>=</span> self.tx {
</span></span><span style=display:flex><span>                                tx.send(()).unwrap();
</span></span><span style=display:flex><span>                                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                            }
</span></span><span style=display:flex><span>                        }
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>        tx
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This actor implementation is very simple, but does what Actor should do - it limits access to inner values to just one thread.
Beside that it doesn&rsquo;t do any work it doesn&rsquo;t have to, one inefficiency I&rsquo;ve had to resort to was checking count in methods that
don&rsquo;t return any values, so I know when to finish benchmark iteration. The most time consuming thing in this implementation is
sending values over channels - something that you cannot avoid in Actor model.</p><h1 id=mutex-implementation>Mutex implementation<a hidden class=anchor aria-hidden=true href=#mutex-implementation>#</a></h1><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rs data-lang=rs><span style=display:flex><span><span style=color:#75715e>#[derive(Default)]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BenchMutex</span> {
</span></span><span style=display:flex><span>    count: <span style=color:#a6e22e>Mutex</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>i64</span><span style=color:#f92672>&gt;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT
</span></span></span><span style=display:flex><span><span style=color:#e6db74></span>    tx: Option<span style=color:#f92672>&lt;</span>mpsc::Sender<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;&gt;</span>,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>impl</span> BenchMutex {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>new</span>(m: <span style=color:#a6e22e>mpsc</span>::Sender<span style=color:#f92672>&lt;</span>()<span style=color:#f92672>&gt;</span>) -&gt; <span style=color:#a6e22e>Self</span> {
</span></span><span style=display:flex><span>        Self {
</span></span><span style=display:flex><span>            tx: Some(m),
</span></span><span style=display:flex><span>            <span style=color:#f92672>..</span>Default::default()
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>increase_by</span>(<span style=color:#f92672>&amp;</span>self, i: <span style=color:#66d9ef>i64</span>) {
</span></span><span style=display:flex><span>        (<span style=color:#f92672>*</span>self.count.lock().<span style=color:#66d9ef>await</span>) <span style=color:#f92672>+=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decrease_by</span>(<span style=color:#f92672>&amp;</span>self, i: <span style=color:#66d9ef>i64</span>) {
</span></span><span style=display:flex><span>        (<span style=color:#f92672>*</span>self.count.lock().<span style=color:#66d9ef>await</span>) <span style=color:#f92672>-=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>increase_by_checked</span>(<span style=color:#f92672>&amp;</span>self, i: <span style=color:#66d9ef>i64</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> v <span style=color:#f92672>=</span> self.count.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>v <span style=color:#f92672>+=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>v <span style=color:#f92672>==</span> REACHED_COUNT_SIGNAL_AMOUNT {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(tx) <span style=color:#f92672>=</span> self.tx.clone() {
</span></span><span style=display:flex><span>                tx.send(()).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>decrease_by_checked</span>(<span style=color:#f92672>&amp;</span>self, i: <span style=color:#66d9ef>i64</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> v <span style=color:#f92672>=</span> self.count.lock().<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>v <span style=color:#f92672>-=</span> i;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#f92672>*</span>v <span style=color:#f92672>==</span> REACHED_COUNT_SIGNAL_AMOUNT {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>let</span> Some(tx) <span style=color:#f92672>=</span> self.tx.clone() {
</span></span><span style=display:flex><span>                tx.send(()).<span style=color:#66d9ef>await</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get</span>(<span style=color:#f92672>&amp;</span>self) -&gt; <span style=color:#66d9ef>i64</span> {
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>self.count.lock().<span style=color:#66d9ef>await</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Again - very simple struct. I&rsquo;ve added <code>_checked</code> methods and made them do the same extra work that Actor had to do to know when
to stop bench iteration. I was a little worried that this small value check might in fact slow Mutex because I was holding the lock
longer than I had to, but that didn&rsquo;t turn out to be true.</p><h1 id=mutex-vs-actor-benchmark>Mutex vs Actor benchmark<a hidden class=anchor aria-hidden=true href=#mutex-vs-actor-benchmark>#</a></h1><h2 id=mutex-vs-actor-that-returns-values>Mutex vs Actor that returns values<a hidden class=anchor aria-hidden=true href=#mutex-vs-actor-that-returns-values>#</a></h2><h3 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h3><pre tabindex=0><code>mutex vs actor/mutex    time:   [1.4809 ms 1.4839 ms 1.4872 ms]
                        change: [+288.15% +290.30% +292.68%] (p = 0.00 &lt; 0.05)
                        Performance has regressed.
Found 9 outliers among 100 measurements (9.00%)
  5 (5.00%) high mild
  4 (4.00%) high severe
mutex vs actor/actor    time:   [4.5462 ms 4.5587 ms 4.5713 ms]
                        change: [-96.680% -96.664% -96.648%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 5 outliers among 100 measurements (5.00%)
  1 (1.00%) low mild
  2 (2.00%) high mild
  2 (2.00%) high severe
</code></pre><p>As you can see Mutex version turned out 3x faster. It doesn&rsquo;t really surprise me because this actor implementation was returning values
over oneshot channel, which is something that you might sometimes want, but I&rsquo;m sure it slows it down significantly. I&rsquo;ve mainly decided
to make actor return values because it made for easier benchmark setup. It&rsquo;s good to know though how much slower is returning values over channel
vs memory access. This benchmark results should apply to all actor methods that modify state and want to know new value instantly.</p><h2 id=mutex-vs-actor-that-dont-have-to-return-values>Mutex vs Actor that don&rsquo;t have to return values<a hidden class=anchor aria-hidden=true href=#mutex-vs-actor-that-dont-have-to-return-values>#</a></h2><h3 id=results-1>Results<a hidden class=anchor aria-hidden=true href=#results-1>#</a></h3><pre tabindex=0><code>mutex vs actor &#39;async&#39;/mutex
                        time:   [1.3995 ms 1.4029 ms 1.4067 ms]
                        change: [+17.433% +17.905% +18.354%] (p = 0.00 &lt; 0.05)
mutex vs actor &#39;async&#39;/actor
                        time:   [2.7879 ms 2.7944 ms 2.8008 ms]
                        change: [+48.814% +49.399% +49.947%] (p = 0.00 &lt; 0.05)
</code></pre><p>I&rsquo;ve added &lsquo;async&rsquo; version of the benchmark. &lsquo;Async&rsquo; here means that caller of actor doesn&rsquo;t want to get values back, so he&rsquo;s essentially just sending Message over
channel and leaves. This required additional check to know when Actor received all messages. To keep both implementations the same I&rsquo;ve made Mutex also do
the same equality check thinking that it would significantly increase bench time for Mutex, but to my surprise the equality check was so fast, that it
didn&rsquo;t make any difference in Mutex time. There was a difference for Actor implementation - without the need to send return signal on each Message
Actors became ~40% faster. They&rsquo;re still 2x slower than Mutexes though.</p><h2 id=higher-concurrency>Higher concurrency<a hidden class=anchor aria-hidden=true href=#higher-concurrency>#</a></h2><p>In first set of benchmarks I was spawning 10000 futures per bench iteration. I&rsquo;ve decided to see what happens if I increase it by x10. Is the time going to change
linearly for both implementations or are Mutexes going to suffer because they have to fight for each lock?</p><h3 id=results-2>Results<a hidden class=anchor aria-hidden=true href=#results-2>#</a></h3><pre tabindex=0><code>mutex vs actor &#39;sync&#39;/mutex
                        time:   [16.629 ms 16.762 ms 16.908 ms]
                        change: [+11058% +11156% +11266%] (p = 0.00 &lt; 0.05)
mutex vs actor &#39;sync&#39;/actor
                        time:   [48.231 ms 48.551 ms 48.909 ms]
                        change: [+9403.5% +9498.0% +9591.7%] (p = 0.00 &lt; 0.05)
mutex vs actor &#39;async&#39;/mutex
                        time:   [16.613 ms 16.667 ms 16.730 ms]
                        change: [+1081.8% +1086.4% +1091.2%] (p = 0.00 &lt; 0.05)
mutex vs actor &#39;async&#39;/actor
                        time:   [32.053 ms 32.181 ms 32.353 ms]
                        change: [+1047.2% +1052.8% +1059.3%] (p = 0.00 &lt; 0.05)
</code></pre><p>So that didn&rsquo;t really happen. Mutexes are still 2x faster than actors that don&rsquo;t return values and 3x faster than actors that return values.
I think that actors can make some designs simpler and mutexes can be hard to use, but when it comes to performance it seems that Mutexes
are clear winner.</p><p>This test was very simple - it was just &lsquo;dumb&rsquo; value access and modification, but I still find the results interesting and hopefully one of you did as well.</p></div><footer class=post-footer><ul class=post-tags></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//nxyt.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://nxyt.pl/blog>just some developer thoughts</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>