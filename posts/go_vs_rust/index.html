<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang vs Rust | just some developer thoughts</title><meta name=keywords content><meta name=description content="Yes, it&rsquo;s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later I&rsquo;ve developed a view that typescript doesn&rsquo;t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? It&rsquo;s interpreted, so we need to package runtime with our code to get it to work, even if it doesn&rsquo;t have benefits of compiled languages we need compile step, it doesn&rsquo;t have good native tooling (you need 3rd party projects for things like formatting), it&rsquo;s not very safe language (f."><meta name=author content><link rel=canonical href=https://nxyt.pl/blog/posts/go_vs_rust/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nxyt.pl/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nxyt.pl/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nxyt.pl/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://nxyt.pl/blog/apple-touch-icon.png><link rel=mask-icon href=https://nxyt.pl/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script><meta property="og:title" content="Golang vs Rust"><meta property="og:description" content="Yes, it&rsquo;s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later I&rsquo;ve developed a view that typescript doesn&rsquo;t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? It&rsquo;s interpreted, so we need to package runtime with our code to get it to work, even if it doesn&rsquo;t have benefits of compiled languages we need compile step, it doesn&rsquo;t have good native tooling (you need 3rd party projects for things like formatting), it&rsquo;s not very safe language (f."><meta property="og:type" content="article"><meta property="og:url" content="https://nxyt.pl/blog/posts/go_vs_rust/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-20T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Golang vs Rust"><meta name=twitter:description content="Yes, it&rsquo;s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later I&rsquo;ve developed a view that typescript doesn&rsquo;t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? It&rsquo;s interpreted, so we need to package runtime with our code to get it to work, even if it doesn&rsquo;t have benefits of compiled languages we need compile step, it doesn&rsquo;t have good native tooling (you need 3rd party projects for things like formatting), it&rsquo;s not very safe language (f."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nxyt.pl/blog/posts/"},{"@type":"ListItem","position":3,"name":"Golang vs Rust","item":"https://nxyt.pl/blog/posts/go_vs_rust/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang vs Rust","name":"Golang vs Rust","description":"Yes, it\u0026rsquo;s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later I\u0026rsquo;ve developed a view that typescript doesn\u0026rsquo;t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? It\u0026rsquo;s interpreted, so we need to package runtime with our code to get it to work, even if it doesn\u0026rsquo;t have benefits of compiled languages we need compile step, it doesn\u0026rsquo;t have good native tooling (you need 3rd party projects for things like formatting), it\u0026rsquo;s not very safe language (f.","keywords":[],"articleBody":"Yes, itâ€™s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later Iâ€™ve developed a view that typescript doesnâ€™t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? Itâ€™s interpreted, so we need to package runtime with our code to get it to work, even if it doesnâ€™t have benefits of compiled languages we need compile step, it doesnâ€™t have good native tooling (you need 3rd party projects for things like formatting), itâ€™s not very safe language (f.e. it doesnâ€™t protect you against accessing out of bounds index), it doesnâ€™t encourage good error handling (you donâ€™t even know which functions can throw errors) and so on. The only benefits I see TS have are big ecosystem, frontend \u003c-\u003e backend code sharing and many people already know TS so itâ€™s easy to hire for. If you ask me, the only worthwhile thing here is sharing code between your services, but this can also be done across languages (in my projects Iâ€™m often depending heavily on sharing types between Rust and TS). Given those things Iâ€™ve started looking for alternatives and two stand out among the crowd - Golang and Rust. This post is my subjective comparison of two languages\nErgonomics Error handling Letâ€™s start with things that both languages have in common - they return errors as values. Itâ€™s very nice approach that forces you to handle error path right away. I certainly prefer this approach to throwing and catching errors. Even if you want to ignore error handling (both languages provide you that option), with errors as values you know if function is fallible just by looking at its signature - great stuff.\nNow letâ€™s see how it works in practice. Weâ€™ll start with Golang.\nfunc fallible() (string, error) { return \"\", fmt.Errorf(\"this function failed\") } func run() error { retValue, err := fallible() if err != nil { // handle error, it's common to handle errors by returning them (manual error bubbling) return err } // do something with retValue return nil } And before we make any judgements hereâ€™s Rust approach\nfn fallible() -\u003e Result\u003cString, String\u003e { return Err(\"this function failed\".into()); } fn run_bubbling() -\u003e Result\u003c(), String\u003e { // if fallible returns error, then error is automagically returned from run_bubbling // if it's Ok then we can use returned String from 'fallibleResult' variable let fallibleResult = fallible()?; } // match statements are a bit more verbose, but sometimes you don't want to return error up the call stack // or you need to do something before bubbling fn run_match() -\u003e Result\u003c(), String\u003e { let fallibleResult = fallible(); match fallibleResult { Ok(text) =\u003e { // handle Ok case } Err(e) =\u003e { // handle Err case } } } fn run_let_else -\u003e Result\u003c(), String\u003e { // it's a bit similar to error bubbling but allows us to add some extra logic let Ok(fallibleResult) = fallible() else { // handle error case // you cannot access Error value though, so it's more usefull for // unwrapping Options, not Results // this code path could be used to return from the function or provide some // default value }; // use fallibleResult } As you can see Rust provides you with much more choice in the way you want to handle errors. Is that a good thing? Depends on who you ask. Manually handling errors is fine, but I wish Golang had syntax that allowed error bubbling. Something as simple as â€˜?â€™ operator, that would return error and zero values for other arguments (if error is not nil). Itâ€™d make Go even more readable and I donâ€™t think it would lose anything in the process. One more thing I donâ€™t like about Go approach is the fact that in case of Error you need to return all values. It can sometimes lead to bad behavior as sometimes people treat zero values to indicate that something went wrong. One example of such thing Iâ€™ve encountered was in Kubernetes Cilium Gateway API. Stripping whole URL paths required you to replace /some/path with empty string, but proxy that Cilium depends on (Envoy) decided to return early if it encounters zero value string (empty string). This meant that there was no way to strip paths and I had to file PR with some less than ideal workarounds to get Gateway API to work correctly. This wouldnâ€™t happen with Option/Result types since they indicate intent clearly (Iâ€™d argue that zero values donâ€™t do that). Rust on the other hand is very readable to me, allows faster coding as you donâ€™t need 3 additional lines with every fallible function, but it also allows some silly mistakes to creep in. Sometimes you should not bubble errors, but can do that as it can quickly become a habit. Itâ€™s worth it trade off if you ask me, and I much prefer Rust error handling over Go approach.\nSum types Part of the reason why Rust error handling works so great is the fact it has sum types (i.e. types that can be A or B or Câ€¦). Thanks to this we can model things like Option (which is Someâ€™ type holding value or empty â€˜Noneâ€™ type) or Result (same as Option, but now itâ€™s â€˜Okâ€™ or â€˜Errâ€™ both holding values). Without them â€˜?â€™ operator wouldnâ€™t be possible. Sum types are very helpful in modeling any problem and I wish Go had them. In Go weâ€™d typically rely on interfaces, but itâ€™s not as clean as sum types (depending on the problem).\nInterfaces and Traits Describing abstract behavior makes our architecture less coupled and more flexible. Both languages have ways to allow what: Golang uses interfaces while Rust uses Traits. Theyâ€™re very similar, both describe set of functions that concrete types have to implement, the biggest difference is the fact that Golang interfaces are implicit. If you have interface stringer and your type has function String() string then it automatically implements stringer interface. In Rust we have to explicitly write impl Stringer for MyType{...}. Both approaches are fine if you ask me, explicitly implementing interfaces has one advantage - you know where specific methods are located. With Golang I sometimes find myself looking for methods implementing some interfaces as they are scattered among multiple types. Golang also has syntax allowing to make sure that type implements some interface var _ SomeInterface = \u0026MyType{}, but itâ€™s quiet ugly. Since it does its job I wonâ€™t complain about that too much :p\nAsync model One of the biggest advantages of Golang is its async system. Go is one of not so many languages that have built in support for concurrency. Itâ€™s very different from how most languages approach this topic. All code is â€˜syncâ€™ and to run something in a background we spawn another goroutine (think lightweight threads). Want to run many operations and wait for their results? Create message passing channel, spawn X goroutines and wait until they all return. I think itâ€™s easier mental model, but is much more verbose (I see a trend here). This model has one huge advantage - all functions can be run this way. We donâ€™t have split between sync and async functions, which is a great benefit. Rust on the other way has this sync/async split and doesnâ€™t handle async automatically, instead it has libraries that create async runtimes (like Tokio). Rust async ecosystem is not fully mature yet (async functions in traits are still problematic), but itâ€™s good enough to be used in production setting. Because Rust is as expressive as it is, itâ€™s totally possible to emulate Golang async model in Rust, although it doesnâ€™t look very idiomatic.\nExpressiveness Expressiveness is a double-edged sword. It allows hiding complexity, but can also lead to awful code spaghetti. Itâ€™s very hard to find the right balance here and Golang chose to be simple instead of expressive. Rust on the other hand gets new syntax with every release, to let you handle itâ€™s complexities a little bit more ergonomic, but there is such thing as too many features (C++ :P). Personally I donâ€™t think Rust crossed that point yet.\nReadability Thereâ€™s nothing more subjective than readability. Gophers swear by Go simplicity and claim that simple language is readable language. Rustaceans say that the right combination of functional style programming and syntactic sugar make for the most maintainable code. My opinion here is that Go error handling can distract you from implementing business logic. I donâ€™t love the fact that every function call quickly turns into 4 lines (with if err != nil style error handling). Maybe itâ€™s because Iâ€™m past the big initial learning curve investment that Rust requires, but Rust seems more readable to me. Go is not far off and with alternative error handling Iâ€™d give this point to Go. Maybe itâ€™ll happen in the future.\nTooling Both languages have great tooling to deal with testing/formatting/code sharing. I think they are gold standard in the language industry and inspire other languages to come with similar tools. Iâ€™d say they are equal (equally great) in that department.\nSimplicity Of course this point goes to Go. Go is simple by design. Thereâ€™s no magic, given enough time you can easily understand any codebase. I donâ€™t like all Go design choices, but I have to say they are consistent on their initial goal of making simple language. Rust on the other hand is as complex as it gets. There are plenty ways to do one thing, it has ton of features, it requires you to understand how it works to work with its ecosystem. You could write Go after watching one tutorial, but Rust will usually take much more until youâ€™ll feel comfortable. One more thing on that front - Rust requires you to manage your references lifetimes, which is absolute pain. Iâ€™d gladly take Rust with GC that allows specifying lifetimes when you need extra performance, but sadly thereâ€™s no such thing and lifetimes tend to infest other code pretty quickly.\nDefer vs Drop Both languages use different schemes for cleanup after some piece of code finished executing. Golang uses defer while Rust has Drop trait. There are times, that Iâ€™d like to use Defer in Rust (in fact itâ€™s possible with some macros that implement Drop on empty struct), but Drop is elegant in itself and works pretty well. Golangâ€™s defer is also nice, but again - leads to verbose code. If we open a file, weâ€™re responsible for manually closing it (usually inside defer). With something like Drop it could be automatically closed when all references are GCd. Itâ€™s just another convenience that Golang drops (pun intended) in favor of simplicity.\nSafety Rust is touted as THE SAFE LANGUAGE, and it lives up to its promises. Rust successfully eliminates a whole class of bugs and programs made with it just do not crash. Itâ€™s probably the most important characteristic of the language, and therefore it wins in safety match with Golang. Go is â€˜safeâ€™ language too. Itâ€™s garbage collected, so you donâ€™t need to worry about memory leaks (unless you have logic bug and something holds reference to some piece of the memory when it shouldnâ€™t), accessing out of bounds array indices will panic instead of giving you access to memory you should not access, but if you compare that to Rust itâ€™s pretty bleak. Additionally, thereâ€™s no way to tell if some pointer is nil or not (Zig has concept of pointers that cannot be nil which is nice) and you either need to have a lot of guard code or make sure that thereâ€™s no way nil pointer will be passed to a function. Pointers are often used instead as Rust Options, but because theyâ€™re not single purpose using it as such can get quiet messy. Overall Rust is much safer language.\nPerformance People often cite performance as Rust strength, but IMAO itâ€™s not something we should focus on. First - itâ€™s really hard to write efficient Rust code. Itâ€™ll often require you to deeply understand packages youâ€™re using, itâ€™s async model, the best way to structure your code and a bunch of other things. I think whatâ€™s really important is that even â€˜good enoughâ€™ Rust is fast. So is Go. You can go an extra mile with Rust to make it the most performant solution, but if youâ€™re not building something really performance critical donâ€™t obsess over performance. I think itâ€™s pretty nice to know that if I really need performance I have a choice of optimizing my Rust code to the absolute limits.\nCompilation speed Go is ridiculously fast on that front. Go is in fact so fast, that you could use it instead of scripting languages and often not notice a difference. Rust on the other hand is known for itâ€™s slow compile times. Some people really care about that - others donâ€™t. I donâ€™t mind long compile times that much since â€˜if it compiles it worksâ€™ factor that Rust has. If slow compile times werenâ€™t accompanied by Rust no undefined behavior guarantees then Iâ€™d most likely take more problems with it. Thereâ€™s no denying though - this point goes to Golang.\nEcosystem Both systems have big ecosystems with many libraries. Go has advantage of having great standard library. Even if there would be some better choices, using packages provided by the language itself is a great way to make sure that your code will be maintainable in the long run. Rust with its strong guarantees makes for a better 3rd party crates ecosystem thought. I feel that Rust APIs are often easier to use, and I generally trust them more than 3rd party Golang code. Theyâ€™re still both great and better than other languages so thatâ€™s a tie for me.\nSummary Both languages are great. Golang strength lies in its simplicity, which puts less mental strain on the person reading the code. Rust focuses on correctness and feature set that can satisfy everyone. I think you canâ€™t go wrong with either language and picking the best one for a project depends on few things.\nDoes your crew know one of them already? If so pick the one theyâ€™re familiar with or pick Golang (itâ€™s super easy to learn along the way) Is your app performance critical? You canâ€™t go wrong with Rust here. Would your app suffer from GC? Most apps should not care about that, but if your does - pick Rust. Is safety extra important to you? Should your app have 100% uptime? Pick Rust. Do you have many people depending on some project and want them to PR changes they need quickly? Golang. Will you extensively use concurrency for IO bound tasks? Thatâ€™s Golangâ€™s niche! Do you value elegant solutions? Rust! Do you just want to get stuff done? Go! Would you like to learn new language? Pick the one you find more pleasant to look at :P As you can see, I donâ€™t have decisive answer here - mainly because both languages are great choice. If you asked me to choose between C++ or Rust Iâ€™d be much more opinionated here :) Thanks for reading this article, Iâ€™ll come back here in a few years to see if I changed my mind on this topic and how both languages developed. Have a great day ^_^\n","wordCount":"2560","inLanguage":"en","datePublished":"2023-12-20T00:00:00Z","dateModified":"2023-12-20T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://nxyt.pl/blog/posts/go_vs_rust/"},"publisher":{"@type":"Organization","name":"just some developer thoughts","logo":{"@type":"ImageObject","url":"https://nxyt.pl/blog/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nxyt.pl/blog accesskey=h title="just some developer thoughts (Alt + H)">just some developer thoughts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Golang vs Rust</h1><div class=post-meta><span title='2023-12-20 00:00:00 +0000 UTC'>December 20, 2023</span></div></header><div class=post-content><p>Yes, it&rsquo;s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later I&rsquo;ve developed a view that typescript doesn&rsquo;t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? It&rsquo;s interpreted, so we need to package runtime with our code to get it to work, even if it doesn&rsquo;t have benefits of compiled languages we need compile step, it doesn&rsquo;t have good native tooling (you need 3rd party projects for things like formatting), it&rsquo;s not very safe language (f.e. it doesn&rsquo;t protect you against accessing out of bounds index), it doesn&rsquo;t encourage good error handling (you don&rsquo;t even know which functions can throw errors) and so on. The only benefits I see TS have are big ecosystem, frontend &lt;-> backend code sharing and many people already know TS so it&rsquo;s easy to hire for. If you ask me, the only worthwhile thing here is sharing code between your services, but this can also be done across languages (in my projects I&rsquo;m often depending heavily on sharing types between Rust and TS).
Given those things I&rsquo;ve started looking for alternatives and two stand out among the crowd - Golang and Rust. This post is my subjective comparison of two languages</p><h1 id=ergonomics>Ergonomics<a hidden class=anchor aria-hidden=true href=#ergonomics>#</a></h1><h2 id=error-handling>Error handling<a hidden class=anchor aria-hidden=true href=#error-handling>#</a></h2><p>Let&rsquo;s start with things that both languages have in common - they return errors as values. It&rsquo;s very nice approach that forces you to handle error path right away. I certainly prefer this approach to throwing and catching errors. Even if you want to ignore error handling (both languages provide you that option), with errors as values you know if function is fallible just by looking at its signature - great stuff.</p><p>Now let&rsquo;s see how it works in practice. We&rsquo;ll start with Golang.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>fallible</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;this function failed&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>run</span>() <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>retValue</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fallible</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle error, it&#39;s common to handle errors by returning them (manual error bubbling)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>err</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// do something with retValue
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And before we make any judgements here&rsquo;s Rust approach</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>fallible</span>() -&gt; Result<span style=color:#f92672>&lt;</span>String, String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Err(<span style=color:#e6db74>&#34;this function failed&#34;</span>.into());
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run_bubbling</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// if fallible returns error, then error is automagically returned from run_bubbling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// if it&#39;s Ok then we can use returned String from &#39;fallibleResult&#39; variable
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> fallibleResult <span style=color:#f92672>=</span> fallible()<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// match statements are a bit more verbose, but sometimes you don&#39;t want to return error up the call stack
</span></span></span><span style=display:flex><span><span style=color:#75715e>// or you need to do something before bubbling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run_match</span>() -&gt; Result<span style=color:#f92672>&lt;</span>(), String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> fallibleResult <span style=color:#f92672>=</span> fallible();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> fallibleResult {
</span></span><span style=display:flex><span>    Ok(text) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// handle Ok case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    Err(e) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// handle Err case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>run_let_else</span> -&gt; Result<span style=color:#f92672>&lt;</span>(), String<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#75715e>// it&#39;s a bit similar to error bubbling but allows us to add some extra logic
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>let</span> Ok(fallibleResult) <span style=color:#f92672>=</span> fallible() <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// handle error case
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// you cannot access Error value though, so it&#39;s more usefull for
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// unwrapping Options, not Results
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// this code path could be used to return from the function or provide some
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// default value
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  };
</span></span><span style=display:flex><span>  <span style=color:#75715e>// use fallibleResult
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>As you can see Rust provides you with much more choice in the way you want to handle errors. Is that a good thing? Depends on who you ask. Manually handling errors is fine, but I wish Golang had syntax that allowed error bubbling. Something as simple as &lsquo;?&rsquo; operator, that would return error and zero values for other arguments (if error is not nil). It&rsquo;d make Go even more readable and I don&rsquo;t think it would lose anything in the process. One more thing I don&rsquo;t like about Go approach is the fact that in case of Error you need to return all values. It can sometimes lead to bad behavior as sometimes people treat zero values to indicate that something went wrong. One example of such thing I&rsquo;ve encountered was in Kubernetes Cilium Gateway API. Stripping whole URL paths required you to replace <code>/some/path</code> with empty string, but proxy that Cilium depends on (Envoy) decided to return early if it encounters zero value string (empty string). This meant that there was no way to strip paths and I had to file PR with some less than ideal workarounds to get Gateway API to work correctly. This wouldn&rsquo;t happen with Option/Result types since they indicate intent clearly (I&rsquo;d argue that zero values don&rsquo;t do that).
Rust on the other hand is very readable to me, allows faster coding as you don&rsquo;t need 3 additional lines with every fallible function, but it also allows some silly mistakes to creep in. Sometimes you should not bubble errors, but can do that as it can quickly become a habit. It&rsquo;s worth it trade off if you ask me, and I much prefer Rust error handling over Go approach.</p><h2 id=sum-types>Sum types<a hidden class=anchor aria-hidden=true href=#sum-types>#</a></h2><p>Part of the reason why Rust error handling works so great is the fact it has sum types (i.e. types that can be A or B or C&mldr;). Thanks to this we can model things like Option (which is Some&rsquo; type holding value or empty &lsquo;None&rsquo; type) or Result (same as Option, but now it&rsquo;s &lsquo;Ok&rsquo; or &lsquo;Err&rsquo; both holding values). Without them &lsquo;?&rsquo; operator wouldn&rsquo;t be possible. Sum types are very helpful in modeling any problem and I wish Go had them. In Go we&rsquo;d typically rely on interfaces, but it&rsquo;s not as clean as sum types (depending on the problem).</p><h2 id=interfaces-and-traits>Interfaces and Traits<a hidden class=anchor aria-hidden=true href=#interfaces-and-traits>#</a></h2><p>Describing abstract behavior makes our architecture less coupled and more flexible. Both languages have ways to allow what: Golang uses interfaces while Rust uses Traits. They&rsquo;re very similar, both describe set of functions that concrete types have to implement, the biggest difference is the fact that Golang interfaces are implicit. If you have interface <code>stringer</code> and your type has function <code>String() string</code> then it automatically implements <code>stringer</code> interface.
In Rust we have to explicitly write <code>impl Stringer for MyType{...}</code>. Both approaches are fine if you ask me, explicitly implementing interfaces has one advantage - you know where specific methods are located. With Golang I sometimes find myself looking for methods implementing some interfaces as they are scattered among multiple types. Golang also has syntax allowing to make sure that type implements some interface <code>var _ SomeInterface = &MyType{}</code>, but it&rsquo;s quiet ugly. Since it does its job I won&rsquo;t complain about that too much :p</p><h2 id=async-model>Async model<a hidden class=anchor aria-hidden=true href=#async-model>#</a></h2><p>One of the biggest advantages of Golang is its async system. Go is one of not so many languages that have built in support for concurrency. It&rsquo;s very different from how most languages approach this topic. All code is &lsquo;sync&rsquo; and to run something in a background we spawn another goroutine (think lightweight threads). Want to run many operations and wait for their results? Create message passing channel, spawn X goroutines and wait until they all return. I think it&rsquo;s easier mental model, but is much more verbose (I see a trend here). This model has one huge advantage - all functions can be run this way. We don&rsquo;t have split between sync and async functions, which is a great benefit.
Rust on the other way has this sync/async split and doesn&rsquo;t handle async automatically, instead it has libraries that create async runtimes (like Tokio). Rust async ecosystem is not fully mature yet (async functions in traits are still problematic), but it&rsquo;s good enough to be used in production setting. Because Rust is as expressive as it is, it&rsquo;s totally possible to emulate Golang async model in Rust, although it doesn&rsquo;t look very idiomatic.</p><h2 id=expressiveness>Expressiveness<a hidden class=anchor aria-hidden=true href=#expressiveness>#</a></h2><p>Expressiveness is a double-edged sword. It allows hiding complexity, but can also lead to awful code spaghetti. It&rsquo;s very hard to find the right balance here and Golang chose to be simple instead of expressive. Rust on the other hand gets new syntax with every release, to let you handle it&rsquo;s complexities a little bit more ergonomic, but there is such thing as too many features (C++ :P). Personally I don&rsquo;t think Rust crossed that point yet.</p><h2 id=readability>Readability<a hidden class=anchor aria-hidden=true href=#readability>#</a></h2><p>There&rsquo;s nothing more subjective than readability. Gophers swear by Go simplicity and claim that simple language is readable language. Rustaceans say that the right combination of functional style programming and syntactic sugar make for the most maintainable code. My opinion here is that Go error handling can distract you from implementing business logic. I don&rsquo;t love the fact that every function call quickly turns into 4 lines (with <code>if err != nil</code> style error handling).
Maybe it&rsquo;s because I&rsquo;m past the big initial learning curve investment that Rust requires, but Rust seems more readable to me. Go is not far off and with alternative error handling I&rsquo;d give this point to Go. Maybe it&rsquo;ll happen in the future.</p><h2 id=tooling>Tooling<a hidden class=anchor aria-hidden=true href=#tooling>#</a></h2><p>Both languages have great tooling to deal with testing/formatting/code sharing. I think they are gold standard in the language industry and inspire other languages to come with similar tools. I&rsquo;d say they are equal (equally great) in that department.</p><h2 id=simplicity>Simplicity<a hidden class=anchor aria-hidden=true href=#simplicity>#</a></h2><p>Of course this point goes to Go. Go is simple by design. There&rsquo;s no magic, given enough time you can easily understand any codebase. I don&rsquo;t like all Go design choices, but I have to say they are consistent on their initial goal of making simple language.
Rust on the other hand is as complex as it gets. There are plenty ways to do one thing, it has ton of features, it requires you to understand how it works to work with its ecosystem. You could write Go after watching one tutorial, but Rust will usually take much more until you&rsquo;ll feel comfortable.
One more thing on that front - Rust requires you to manage your references lifetimes, which is absolute pain. I&rsquo;d gladly take Rust with GC that allows specifying lifetimes when you need extra performance, but sadly there&rsquo;s no such thing and lifetimes tend to infest other code pretty quickly.</p><h2 id=defer-vs-drop>Defer vs Drop<a hidden class=anchor aria-hidden=true href=#defer-vs-drop>#</a></h2><p>Both languages use different schemes for cleanup after some piece of code finished executing. Golang uses defer while Rust has Drop trait. There are times, that I&rsquo;d like to use Defer in Rust (in fact it&rsquo;s possible with some macros that implement Drop on empty struct), but Drop is elegant in itself and works pretty well.
Golang&rsquo;s defer is also nice, but again - leads to verbose code. If we open a file, we&rsquo;re responsible for manually closing it (usually inside defer). With something like Drop it could be automatically closed when all references are GCd. It&rsquo;s just another convenience that Golang drops (pun intended) in favor of simplicity.</p><h1 id=safety>Safety<a hidden class=anchor aria-hidden=true href=#safety>#</a></h1><p>Rust is touted as THE SAFE LANGUAGE, and it lives up to its promises. Rust successfully eliminates a whole class of bugs and programs made with it just do not crash. It&rsquo;s probably the most important characteristic of the language, and therefore it wins in safety match with Golang.
Go is &lsquo;safe&rsquo; language too. It&rsquo;s garbage collected, so you don&rsquo;t need to worry about memory leaks (unless you have logic bug and something holds reference to some piece of the memory when it shouldn&rsquo;t), accessing out of bounds array indices will panic instead of giving you access to memory you should not access, but if you compare that to Rust it&rsquo;s pretty bleak. Additionally, there&rsquo;s no way to tell if some pointer is nil or not (Zig has concept of pointers that cannot be nil which is nice) and you either need to have a lot of guard code or make sure that there&rsquo;s no way nil pointer will be passed to a function. Pointers are often used instead as Rust Options, but because they&rsquo;re not single purpose using it as such can get quiet messy.
Overall Rust is much safer language.</p><h1 id=performance>Performance<a hidden class=anchor aria-hidden=true href=#performance>#</a></h1><p>People often cite performance as Rust strength, but IMAO it&rsquo;s not something we should focus on. First - it&rsquo;s really hard to write efficient Rust code. It&rsquo;ll often require you to deeply understand packages you&rsquo;re using, it&rsquo;s async model, the best way to structure your code and a bunch of other things. I think what&rsquo;s really important is that even &lsquo;good enough&rsquo; Rust is fast. So is Go. You can go an extra mile with Rust to make it the most performant solution, but if you&rsquo;re not building something really performance critical don&rsquo;t obsess over performance. I think it&rsquo;s pretty nice to know that if I really need performance I have a choice of optimizing my Rust code to the absolute limits.</p><h1 id=compilation-speed>Compilation speed<a hidden class=anchor aria-hidden=true href=#compilation-speed>#</a></h1><p>Go is ridiculously fast on that front. Go is in fact so fast, that you could use it instead of scripting languages and often not notice a difference. Rust on the other hand is known for it&rsquo;s slow compile times. Some people really care about that - others don&rsquo;t. I don&rsquo;t mind long compile times that much since &lsquo;if it compiles it works&rsquo; factor that Rust has. If slow compile times weren&rsquo;t accompanied by Rust <code>no undefined behavior</code> guarantees then I&rsquo;d most likely take more problems with it.
There&rsquo;s no denying though - this point goes to Golang.</p><h1 id=ecosystem>Ecosystem<a hidden class=anchor aria-hidden=true href=#ecosystem>#</a></h1><p>Both systems have big ecosystems with many libraries. Go has advantage of having great standard library. Even if there would be some better choices, using packages provided by the language itself is a great way to make sure that your code will be maintainable in the long run. Rust with its strong guarantees makes for a better 3rd party crates ecosystem thought. I feel that Rust APIs are often easier to use, and I generally trust them more than 3rd party Golang code. They&rsquo;re still both great and better than other languages so that&rsquo;s a tie for me.</p><h1 id=summary>Summary<a hidden class=anchor aria-hidden=true href=#summary>#</a></h1><p>Both languages are great. Golang strength lies in its simplicity, which puts less mental strain on the person reading the code. Rust focuses on correctness and feature set that can satisfy everyone. I think you can&rsquo;t go wrong with either language and picking the best one for a project depends on few things.</p><ol><li>Does your crew know one of them already? If so pick the one they&rsquo;re familiar with or pick Golang (it&rsquo;s super easy to learn along the way)</li><li>Is your app performance critical? You can&rsquo;t go wrong with Rust here.</li><li>Would your app suffer from GC? Most apps should not care about that, but if your does - pick Rust.</li><li>Is safety extra important to you? Should your app have 100% uptime? Pick Rust.</li><li>Do you have many people depending on some project and want them to PR changes they need quickly? Golang.</li><li>Will you extensively use concurrency for IO bound tasks? That&rsquo;s Golang&rsquo;s niche!</li><li>Do you value elegant solutions? Rust! Do you just want to get stuff done? Go!</li><li>Would you like to learn new language? Pick the one you find more pleasant to look at :P</li></ol><p>As you can see, I don&rsquo;t have decisive answer here - mainly because both languages are great choice. If you asked me to choose between C++ or Rust I&rsquo;d be much more opinionated here :)
Thanks for reading this article, I&rsquo;ll come back here in a few years to see if I changed my mind on this topic and how both languages developed. Have a great day ^_^</p></div><footer class=post-footer><ul class=post-tags></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//nxyt.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://nxyt.pl/blog>just some developer thoughts</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>