<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Zagadnienia egzamin licencjacki UMCS Informatyka | just some developer thoughts</title><meta name=keywords content><meta name=description content="Krótka powtórka wiedzy wymaganej na obronie pracy licencjackiej na UMCS. Nie jest to wyczerpujące omówienie wszystkich problemów i osobiście polecałbym przeczytać cały ten post 1-2 razy, po czym poszukać materiałów bardziej szczegółowych do wybranych/cięższych tematów. Najzwyczajniej w świecie uznałem, że ucząc się zrobię krótkie podsumowanie każdego tematu tak, żeby mieć chociaż powierzchowne pojęcie na jego temat. Zebranie materiałów w jednym miejscu jest też dobre do utrwalania wiedzy. Proszę korzystać na własne ryzyko ( ͡° ͜ʖ ͡°)"><meta name=author content><link rel=canonical href=https://nxyt.pl/blog/posts/zagadnienia_umcs/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nxyt.pl/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nxyt.pl/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nxyt.pl/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://nxyt.pl/blog/apple-touch-icon.png><link rel=mask-icon href=https://nxyt.pl/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script><meta property="og:title" content="Zagadnienia egzamin licencjacki UMCS Informatyka"><meta property="og:description" content="Krótka powtórka wiedzy wymaganej na obronie pracy licencjackiej na UMCS. Nie jest to wyczerpujące omówienie wszystkich problemów i osobiście polecałbym przeczytać cały ten post 1-2 razy, po czym poszukać materiałów bardziej szczegółowych do wybranych/cięższych tematów. Najzwyczajniej w świecie uznałem, że ucząc się zrobię krótkie podsumowanie każdego tematu tak, żeby mieć chociaż powierzchowne pojęcie na jego temat. Zebranie materiałów w jednym miejscu jest też dobre do utrwalania wiedzy. Proszę korzystać na własne ryzyko ( ͡° ͜ʖ ͡°)"><meta property="og:type" content="article"><meta property="og:url" content="https://nxyt.pl/blog/posts/zagadnienia_umcs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-06-30T09:03:20-08:00"><meta property="article:modified_time" content="2023-06-30T09:03:20-08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Zagadnienia egzamin licencjacki UMCS Informatyka"><meta name=twitter:description content="Krótka powtórka wiedzy wymaganej na obronie pracy licencjackiej na UMCS. Nie jest to wyczerpujące omówienie wszystkich problemów i osobiście polecałbym przeczytać cały ten post 1-2 razy, po czym poszukać materiałów bardziej szczegółowych do wybranych/cięższych tematów. Najzwyczajniej w świecie uznałem, że ucząc się zrobię krótkie podsumowanie każdego tematu tak, żeby mieć chociaż powierzchowne pojęcie na jego temat. Zebranie materiałów w jednym miejscu jest też dobre do utrwalania wiedzy. Proszę korzystać na własne ryzyko ( ͡° ͜ʖ ͡°)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nxyt.pl/blog/posts/"},{"@type":"ListItem","position":3,"name":"Zagadnienia egzamin licencjacki UMCS Informatyka","item":"https://nxyt.pl/blog/posts/zagadnienia_umcs/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Zagadnienia egzamin licencjacki UMCS Informatyka","name":"Zagadnienia egzamin licencjacki UMCS Informatyka","description":"Krótka powtórka wiedzy wymaganej na obronie pracy licencjackiej na UMCS. Nie jest to wyczerpujące omówienie wszystkich problemów i osobiście polecałbym przeczytać cały ten post 1-2 razy, po czym poszukać materiałów bardziej szczegółowych do wybranych/cięższych tematów. Najzwyczajniej w świecie uznałem, że ucząc się zrobię krótkie podsumowanie każdego tematu tak, żeby mieć chociaż powierzchowne pojęcie na jego temat. Zebranie materiałów w jednym miejscu jest też dobre do utrwalania wiedzy. Proszę korzystać na własne ryzyko ( ͡° ͜ʖ ͡°)","keywords":[],"articleBody":"Krótka powtórka wiedzy wymaganej na obronie pracy licencjackiej na UMCS. Nie jest to wyczerpujące omówienie wszystkich problemów i osobiście polecałbym przeczytać cały ten post 1-2 razy, po czym poszukać materiałów bardziej szczegółowych do wybranych/cięższych tematów. Najzwyczajniej w świecie uznałem, że ucząc się zrobię krótkie podsumowanie każdego tematu tak, żeby mieć chociaż powierzchowne pojęcie na jego temat. Zebranie materiałów w jednym miejscu jest też dobre do utrwalania wiedzy. Proszę korzystać na własne ryzyko ( ͡° ͜ʖ ͡°)\nWektory i macierze – definicje i podstawowe operacje. Wektory Obiekt matematyczny opisywany za pomocą modułu (wartość), kierunku oraz zwrotu. Wektor w przestrzeni 2d przyjmuje postać pary punktów - na przykład [3, 4], co oznacza że aby stworzyć wektor w przestrzeni 2d należy ruszyć się o 3 punkty na osi X i 4 na osi Y.\nDodawanie i odejmowanie Aby dodać lub odjąć dwa wektory wystarczy odjąć od siebie analogiczne wartości. [-10. 5] + [3, 2] = [-7, 7]\nMnożenie i dzielenie Wektor można pomnożyć lub podzielić przez liczbę, co skutkuje zmianą obu wartości w wektorze. [4,3] * 2 = [8,6]\nIloczyn skalarny [a1, b1] * [a2, b2] = a1 * a2 + b1 * b2. Przykład: [5,3] * [-1, 7] = 5*-1 + 3*7 = -5 + 21 = 16\nMacierze Macierz to układ liczb, symboli lub wyrażeń zapisany w prostokątnej tablicy. Macierze wykorzystywane są przykładowo do rozwiązywania równań liniowych. Rozwiązywanie równań liniowych Funkcje skrótu i ich zastosowanie Funkcja przyporządkowująca dowolnej wartości, wartość o stałej długości. Funkcje skrótu (inaczej hashujące) wykorzystywane są w kryptografii, do tworzenia struktur danych (hashmapy), do oceny integralności danych (caching - sumy kontrolne pozwalają porównać zbiory danych bez porównywania znak po znaku).\nProblemy rekurencyjne Problemy rekurencyjne, to problemy które można rozwiązać korzystając z rekurencji, czyli można taki problem sprowadzić do postaci gdzie jego rozwiązanie zawiera w sobie swoją własną definicję. Przykładem może być ciąg Fibonacciego - Fib(n) = Fib(n-1) + Fib(n-2). Każda funkcja wywołująca siebie samą jest rekurencyjna. Inne problemy rekurencyjne to na przykład algorytmy typu dziel i rządź, gdzie zbiór danych jest dzielony, a następnie na obu połowach zbioru znowu wykonywany jest ten sam algorytm.\nPodstawowe charakterystyki statystyki opisowej i matematycznej Pozycyjne systemy liczbowe i konwersje pomiędzy nimi Metoda zapisywania liczb, w której pozycja cyfry w ciągu oznacza wieloktorność potęgi bazy jaką dana cyfra reprezentuje. W systemie 10 liczba 121 = 1 * 10^2 + 2 * 10^1 + 1 * 1^0. Potęgi bazy zaczynają się od 0 po prawej stronie i rosną o 1. W innych systemach zmienia się wyłącznie wartość bazy. W systemie 5 liczba 434 = 4 * 5^2 + 3 * 5^1 + 4 * 5^0. Zapisując liczbę w ten sposób można obliczyć jej wartość w systemie 10. Każdy system można więc łatwo zapisać w postaci dziesiętnej. Aby zamienić system 10 na inny system należy dzielić liczbę przez bazę danego systemu i zapisywać resztę z dzielenia. 173 w systemie 6 to\n173/6=28 reszta 5 28/6=4 reszta 4 4/6=0 reszta 4 wynik w systemie szóstkowym = 445 Sposoby cyfrowej reprezentacji liczby całkowitej i rzeczywistej Liczby całkowite Liczba zapisywana jest w postaci binarnej. Typ liczby całkowitej (na przykład u8 - unsigned 8) oznacza ilość bitów wykorzystanych do reprezentacji liczby. Jeżeli liczba może być dodatnia lub ujemna należy wykorzystywać typ danych, w którym ostatni bit wykorzystywany jest do przechowywania informacji czy liczba jest dodatnia (jak i8).\nUjemne liczby całkowite W przypadku typów, w których liczba może być ujemna najstarszy bit jest wykorzystywany do informowania o tym czy liczba jest ujemna. Aby zapisać liczbę w postaci ujemnej zapisz jej bezwzględną wartość w postaci binarnej, następnie odwróć wszystkie bity i dodaj 1.\n-7 w systemie dziesiętnym 1) zapisz jako 7 w systemie binarnym w zmiennej typu i8 (8 bitów) 00000111 2) odwróć bity 11111000 3) dodaj 1 11111001 Liczby dziesiętne Norma IEEE 754 stanowi standard zapisywania liczb całkowitych przy użyciu 32 lub 64 bitów. Pierwszy bit podobnie jak w przypadku liczb całkowitych zapisywany jest do kodowania ujemnych liczb (tzn jeśli ma wartość 1 to liczba jest ujemna). Dalej 8/11 bitów koduje wykładnik (nie może składać sie z samych zer lub jedynek), czyli potęgę do jakiej należy podnieść znormalizowaną wartość liczby. Reszta bitów wykorzystywana jest do zapisu liczby w znormalizowanym formacie binarnym.\nTyp, zmienna, obiekt i zarządzanie pamięcią Typ Typy danych niosą informacje na temat tego jak interpretowany powinien być dany wycinek pamięci. Ta sama sekwencja zer i jedynek może oznaczać różne rzeczy, zależnie od tego czy interpretowana jest jako liczba całkowita, zmiennoprzecinkowa lub znak tekstowy.\nZmienna Konstrukt programistyczny składający się z nazwy symbolicznej, miejsce przechowywania oraz wartość.\nObiekt Konstukt złożony z jednego lub więcej typów prostych danych. Przykładem obiektu jest instancja klasy w c++.\nInstrukcje sterujące przepływem programu Instrukcje sterujące zależą od wykorzystywanego języka, najczęstsze to:\nif switch while for while do; while; match break continue goto Protokoły TCP i UDP – porównanie i zastosowanie TCP Priorytetem TCP (Transmission Control Protocol) jest stabilność i niezawodność. TCP wymaga nawiązania połączenia przed przesłaniem właściwych pakietów. Dzięki temu możliwe jest na przykład ponowne przesłanie pakietów, jeżeli nie trafiły one do miejsca docelowego. Dodatkowe zadania związane z nawiązaniem i utrzymaniem tego połączenia zwiększają opóźnienie oraz przepustowość. TCP jest stosowane wszędzie tam gdzie wymagana jest komunikacja z pewnością, że dane dotrą do celu, czyli w większości aplikacji internetowych, stronach internetowych.\nUDP UDP (User Datagram Protocol) nie wymaga nawiązania wcześniejszego połączenia z klientem i od razu wysyła właściwe dane. Poza tym, że UDP nie wykonuje części czynności, nagłówki w tym protokole są również odpowiednio mniejsze (8 bajtów do 20-60 w TCP) UDP wykorzystywane jest tam, gdzie potrzebne jest strumieniowanie danych w czasie rzeczywistym, korzystają z niego często gry komputerowe online.\nOba protokoły mają swój własny zestaw portów na komputerze, przykładowo jedna aplikacja może wykorzystywać port 420/tcp, inna 420/udp.\nAdresowanie w warstwie Internetu modelu TCP/IP Pakiety wysyłane w sieci muszą zawierać adres IP oraz numer portu na który wysyłany jest dany pakiet. Adres składa się z 4 liczb 0-255 (np 192.168.1.1), a port ma numer od 0 do 65535.\nPorównanie zadań przełącznika (switcha) i routera Switch wykorzystuje adresy MAC, Router adresy IP Switche obsługują tylko sieci przewodowe sieci LAN Router pracuje w wyższej warstwie sieci niż switch Switch przekazuje pakiety do nieznanych odbiorców wszystkich, router nie wysyła ich nigdzie Porównanie modelu OSI i TCP/IP model tcp/ip ma 4 warstwy, OSI 7 warstwy TCP/IP to warstwa: aplikacji, transportu, internetowa, dostępu do sieci warstwy OSI to: aplikacji, prezentacji, sesji, transportowa, sieciowa, łącza danych, fizyczna warstwy OSI aplikacji, prezentacji oraz sesji odpowiadają jednej warstwie aplikacji modelu TCP/IP warstwa dostępu do sieci modelu TCP/IP zawiera w sobie dwie warstwy OSI: łącza danych oraz fizyczną Mechanizm enkapsulacji w modelu OSI Ruch sieciowy przekazywany jest do niższych warstw, gdzie pakiety są obudowywane w ramki wymagane przez daną warstwę. Przykładowo warstwa aplikacji przy obudowaniu w warstwę transportową zawiera ramki z wymaganymi adresami odbiorcy.\nObiekt i klasa w wybranym języku programowania zorientowanym obiektowo Javascript:\nclass Rect { constructor(height, width) { this.height = height; this.width = width; } // Getter get area() { return this.calcArea(); } // Method calcArea() { return this.height * this.width; } *getSides() { yield this.height; yield this.width; yield this.height; yield this.width; } } const square = new Rectangle(10, 10); Co tu gadać, koń jaki jest każdy widzi. Klasa definiuje kształ obiektów danego typu, po czym obiekty tworzy się korzystając ze słowa new.\nHermetyzacja, dziedziczenie i polimorfizm w programowaniu obiektowym. Hermetyzacja (enkapsulacja) Ograniczanie dostępu do pól/metod zewnętrznym obiektom. Enkapsulacja pozwala na podejmowanie decyzji nt. tego jak konsumenci mają korzystać z danego API. Przykładem enkapsulacji jest stworzenie klasy, która ma 2 metody publiczne i więcej metod prywatnych. Prywatne metody mogą być wykorzystywane w definicjach publicznych metod, ale nie mogą być wywołane bezpośrednio przez użytkownika.\nDziedziczenie Dziedziczenie pozwala na rozbudowywanie klasy bazowej o nowe pola oraz metody. Szczegóły zależą od konkretnego języka. Z zasady klasy dziedziczące zawierają się w zbiorze klasy bazowej, mogą być więc używane polimorficznie.\nPolimorfizm Możliwość wykorzystywania obiektów różnych typów w ten sam sposób. Przykładem mogą być klasy dziedziczące, które mogą być wykorzystywane w miejscu klasy bazowej. Innym przykładem polimorfizmu są interfejsy, które mogą być implementowane przez różne klasy. Jeśli obiekty różnych klas implementują ten sam interfejs, to mogą być wykorzystywane polimorficznie.\nInterfejsy i klasy abstrakcyjne w programowaniu obiektowym Klasa abstrakcyjna, to klasa która nie może mieć żadnej instancji. Taka klasa dalej może mieć metody statyczne. Interfejsy to forma kontraktu w której często specyfikowana jest tylko sygnatura funkcji i zwracany typ danych.\nParadygmat i przykłady programowania generycznego (rodzajowego) Programowanie generyczne to rodzaj metaprogramowania, gdzie celem jest stworzenie generycznych metod, które mogą działać na różnych typach danych. Zależnie od języka umożliwiane jest to na różne sposoby. C++ wykorzystuje szablony, Java, C#, Typescript, Rust typy generyczne, a Zig (mniej znany język) Comptime (kod Zig, działający na etapie kompilacji, nie w runtime).\nAlgorytmy sortowania Algorytmy sortowania mają różną złożoność czasową i wymaganiami co do pamięci wymaganej do przeprowadzenia sortowania. Algorytmy typu bubble sort mają O(n^2), a quicksort oraz mergesort O(n log(n)). Jest nieskończenie wiele sposobów na posortowanie ciągu wartości, więc opiszę na szybko tylko dwa wydajne algorytmy - mergesort i quicksort. Quicksort dzieli tablicę na dwie części, elementy mniejsze od wybranego pivota (elementu dzielącego tablicę) przerzuca na lewo, większe na prawo. Następnie na obu częściach wykonywany jest quicksort. Mergesort dzieli tablicę na dwie części, a dopiero później łączy je w większe tablice. Różnice w praktyce jest taka, że mergesort najpierw rekursyjnie rozbija problem aż do samego dołu (aż do tablic o rozmiarze 1) i sortuje w trakcie łączenia, quicksort natomiast sortuje połówki tablic, aż cała tablica będzie posortowana.\nStrategia „dziel i zwyciężaj” budowania algorytmów Strategia ta dzieli problem na mniejsze problemy tego samego typu, rozwiązuje je rekursyjnie, po czym scala rozwiązania. Przykłady: quicksort, mergesort, binary search\nAlgorytmy typu zachłannego Algorytm, który w każdym kroku dokonuje decyzji lokalnie optymalnej, czyli takiej która wydaje się najlepsza w danym kroku. Przykładem może być algorytm Dijkstry,\nAlgorytmy z nawrotami Algorytmy, które tworzą drzewo rozwiązań. Jeśli nie spełniają określonego warunku lub trafią na sekwencję opracowaną w przeszłości wracają do innej ścieżki drzewa rozwiązań.\nGrafy, drzewa, kopce – charakterystyka i przykłady zastosowania Grafy Graf to zbiór wierchołków (węzłów) oraz krawędzi. Krawędzie mogą być skierowane, czyli pozwalać na ruch tylko w jedną stronę np: A -\u003e B - możesz z A przejść do B, ale nie odwrotnie. Krawędzie nieskierowane (A – B) pozwalają na ruch w obie strony.\nDrzewa Drzewo to specjalny rodzaj grafu, który zaczyna sie od jednego źródła (root), a każdy węzeł łączy się tylko ze swoim rodzicem i z 0 lub więcej dzieci.\nKopce Kopiec to drzewo, gdzie wartości dziecka są w stałej relacji z wartością rodzica. Inaczej, drzewo układa dane według pewnej hierarchii semantycznej, kopiec według wartości.\nWielowarstwowa organizacja systemów komputerowych Od najniższej:\nwarstwa sprzętowa - wszystkie komponenty i peryferia PC system operacyjny - pozwala na kontakt między użytkownikiem a sprzętem oprogramowanie narzędziowe - sterowniki i programy potrzebne do funkcjonowania systemu oprogramowanie użytkowe - reszta programów użytkownik - człowiek lub inna maszyna konsumująca oprogramowanie System operacyjny – charakterystyka, zadania, klasyfikacja System operacyjny zajmuje się:\nplanowaniem i przydziałem zasobów synchronizacją i komunikacją procesów obsługuje warstwę sprzętową Jest wiele różnych klasyfikacji systemów operacyjnych: ze względu na liczbę wykonywanych programów, sposób przetwarzania itd. Szczerze to mało ciekawe klasyfikacje, które wydają mi się zbędną abstrakcją więc nie będę rozwijał tutaj tematu.\nProcesy i wątki – charakterystyka i problemy Proces, to pewien program wykonywany w systemie, który dostał pulę zasobów do wykorzystania. W obrębie jednego procesu może znajdować się wiele wątków, które mogą być wykonywane równolegle lub na zmianę. Wątki są lżejsze od procesów i program może bez problemu stworzyć wiele tysięcy różnych wątków.\nZarządzanie pamięcią operacyjną w systemie operacyjnym. Programy korzystają z API systemu operacyjnego do alokowania i uwalniania potrzebnej pamięci. Przy wywołaniu odpowiedniego API system szuka wolnego miejsca. Szukanie wolnego miejsca może odbywać się korzystając z jednej z wielu różnych strategii (m.in. pierwsze wolne, najlepsze).\nOrganizacja systemu plików i pamięci zewnętrznej. Systemy plików NFTS/FAT32/EXT4?\nRóżnice pomiędzy obsługą zdarzeń w przerwaniach sprzętowych a obsługą zdarzeń w pętli programowej. Obsługiwanie zdarzeń w pętli programowej jest mało wydajne, ponieważ wymaga ciągłego sprawdzania bitów związanych z danymi wydarzeniami. System nie reaguje bezpośrednio na zdarzenie, tylko czeka aż program dojdzie do danego fragmentu kodu sprawdzającego stan flagi. Prowadzi to do większych opóźnień w reakcji na bodziec. Metoda przerwań polega na tym, że to układy zgłaszają do jednostki centralnej potrzebę obsługi (w przeciwieństwie do pętli programowej gdzie system sprawdza stan układów). Gdy takie zdarzenie ma miejsce system przerywa aktualnie wykonywany kod i zaczyna obsługiwać dane wydarzenie.\nPowody i przykłady stosowania mikrokontrolerów zamiast typowych komputerów. Powody:\nniższa cena mniej ruchomych części (tzn brak systemu, który może wprowadzać całą nową klasę błędów) mniejsze zużycie prądu Przykłady:\nurządzenia RTV/AGD prosta elektronika Modele reprezentacji wiedzy. Źródło\nMechanizmy wnioskowań. Wnioskowanie wstecz - wykazanie prawdziwości hipotezy na podstawie prawdziwości przesłanek. Wnioskowanie wprzód - na podstawie prawdziwych faktów tworzone są nowe prawdziwe twierdzenia. Nowe twierdzenia mogę generować nowe wnioski. Proces jest powtarzany aż dojdzie się do zakładanej hipotezy lub aż skończą się nowe fakty. Metoda rezolucji - dowodzenie przez zaprzeczenie.\nMetody uczenia maszynowego. Uczenie nadzorowane - uczenie następuje w wyniku porównania wyników programu z prawidłowymi odpowiedziami. Uczenie nienadzorowane - Uczenie ze wzmocnieniem - uczenie następuje w wyniku reakcji na dane ze środowiska. Budowa sieci neuronowych. Sieci neuronowe składają się z jednej lub więcej warstw neuronów, z których każdy ma pewien próg aktywacji.\nNormalizacja baz danych – pierwsza, druga i trzecia postać normalna. Pierwsza postać normalna wiersz opisuje jeden obiekt wszystkie kolumny zawierają wartości elementarne/skalarne nie zawiera powtórzeń informacji na temat obiektu kolejność wierszy może być dowolna Druga postać normalna “Relacja jest w drugiej postaci normalnej wtedy i tylko wtedy, gdy jest w I postaci normalnej i żadna kolumna niekluczowa nie jest częściowo funkcyjnie zależna od jakiegokolwiek klucza potencjalnego” - nie pytaj A tak serio: chodzi o to że tabela nie zawiera informacji, które możesz wywnioskować z klucza potencjalnego. Jeśli masz tabelę gdzie są imiona i płcie osób, to przy założeniu że imie jest przypisane do konkretnej płci, informacja o płci jest powtórzeniem danych - możesz ją wywnioskować z klucza potencjalnego (imienia), więc nie jest to druga postać normalna. Trzecia postać normalna “Relacja jest w trzeciej postaci normalnej wtedy i tylko wtedy, gdy jest w II postaci normalnej i żaden atrybut niekluczowy nie jest zależny funkcyjnie od innych atrybutów niekluczowych” - też nie pytaj Znowu bardziej serio: żadna kolumna ma nie być do wywnioskowania z żadnej innej kolumny. Przechowujemy tylko informacje unikalne i jest git. Modele baz danych (logiczny, relacyjny, fizyczny). Źródło\nLogiczny Model obiektów i relacji między danymi obiektami.\nRelacyjny Dane pogrupowane są w relacje reprezentowane przez tabele. Osobiście rozumiem to jako model logiczny, tylko rozbity do postaci normalnej.\nFizyczny Implementacja modelu logicznego w komputerze.\nRodzaje zapytań w języku SQL. SELECT, INSERT, DELETE, UPDATE - robią to co sugerują ich nazwy\nFunkcje w języku SQL. Przykład funkcji SQL w Postgres\nCREATE FUNCTION add(a integer, b integer) RETURNS integer LANGUAGE SQL IMMUTABLE RETURNS NULL ON NULL INPUT RETURN a + b; Transakcje w bazach danych. Wiele operacji w bazach danych mogą być przeprowadzane w obrębie jednej transakcji. Jeśli na którymś kroku transakcja nie powiedzie się, to wszystkie wprowadzone wcześniej zmiany zostaną cofnięte.\nStandardowe metodyki procesu wytwórczego oprogramowania. model kaskadowy - “Obejmuje on pięć głównych czynności, które wykonywane są tylko raz w procesie tworzenia: definiowanie i analizowanie wymagań, projektowanie oprogramowania, implementację i testowanie jednostek, integrację i testowanie systemu oraz wdrożenie i pielęgnację.” model ewolucyjny - stworzenie prototypu, danie go użytkownikowi i tworzenie nowych iteracji oprogramowania na podstawie zebranego feedbacku metody zwinne - metodyki zwinne mają dobrze funkcjonować w zmieniającym się środowisku (na przykład przy niezbyt dobrze zdefiniowanych wymaganiach dla projektu) Metodyki zwinne – SCRUM. SCRUM, metodyka zwinna tworzenia oprogramowania oparta o koncepcję sprintów. Najpierw planowany jest sprint (zakres prac), następnie miejsce ma sprint (najdłuższy etap, bo robiona jest prawdziwa robota), w trakcie sprintu codziennie miejsce mają spotkania scrumowe gdzie każdy bardzo krótko mówi na jakim etapie prac jest i co zamierza zrobić w ciągu najbliższego czasu. Pod koniec sprintu miejsce ma jego przegląd, gdzie kontrolowane są postępy zrobione w trakcie sprintu i wyniki przedstawiane są interesariuszom. Ostatnim etapem jest retrospektywa, w trakcie której zespół może ocenić sprint i podzielić się wiedzą, która może sprawdzić, że kolejne sprinty przebiegną jeszcze sprawniej.\nTestowanie oprogramowania. Testy automatyczne, manualne, CICD pipeline. Szeroki temat i ciężko powiedzieć co może interesować atakujących pracę :P W skrócie - testy automatyczne to testy, które kodujesz sam (na przykład przy użyciu frameworków e2e jak cypress/playwright), testy manualne są wtedy jak płacisz komuś z indii, żeby klikał w buttona i sprawdzał co się dzieje. CICD to rozwinięcie testów automatycznych, gdzie są one uruchamiane przy wrzuceniu kodu i w reakcji na wynik testów może następować aktualizacja aplikacji.\nDiagramy UML. Jak ktoś lubi rysować zamiast programować to można.\nWzorce projektowe programowania obiektowego. Źródło - wzorców jest dużo, więc rzucę sam link. Najważniejsze to: singleton, strategia, fabryka, builder, obserwator, dekorator. Mimo wszystko warto kojarzyć więcej.\nDefinicja funkcji obliczalnej (częściowo rekurencyjnej). “funkcja o argumentach i wartościach w zbiorze liczb naturalnych (lub w zbiorze tekstów), dla której można podać algorytm znajdujący wartość funkcji na podstawie danego argumentu”. Prościej - funkcja obliczalna to funkcja, którą może ‘rozwiązać’ maszyna turinga. Po co komplikują świrusy nie wiem.\nBonus: “Funkcja f (x1, . . . , xn) jest częściowo rekurencyjna, jeśli może być otrzymana z funkcji prostych za pomocą skończonej liczby zastosowań operacji złożenia, rekursji prostej oraz minimum efektywnego.”\nMaszyna Turinga jako model procesów obliczalnych. dobre źródło Maszyna turinga składa się z:\nnieskończonej taśmy z danymi wejściowymi (odpowiednik pamięci komputera). Może zawierać dowolne symbole, ale zwykle są to 0 i 1. głowica zapisująco odczytująca - może odczytywać i zapisywać symbole oraz poruszać się wzdłuż taśmy układ sterowania głowicą (odpowiednik procesora) - reaguje na dane odczytane przez głowicę i wysyła do niej kolejne polecenia Maszyna Turinga jest w stanie rozwiązać wszystkie problemy obliczalne, jeśli więc udowodni się że jakiś problem nie może być rozwiązany przez maszynę turinga, nie należy on do kategorii problemów obliczalnych (nie mogą go rozwiązać nasze komputery).\nZagadnienia nierostrzygalne w kontekście obliczalności. Są zagadnienia, dla których udowodniono, że należą do grupy problemów nierozstrzygalnych: np. problem stopu.\nDefinicja i klasy złożoności obliczeniowej – czasowej i pamięciowej. źródło W skrócie, klasy złożoności oznaczają zbiór języków spełniających wymagania stawiane przez daną maszynę turinga (SPACE, TIME, NSPACE, NTIME).\nGłówne paradygmaty programowania – charakterystyka i przykłady. Obiektowe - program składa się z obiektów i ich wzajemnych oddziaływań. To one są centralnym elementem aplikacji. Funkcyjne - programowanie czerpiące z deklaratywnego paradygmatu programowania. Program powinien składać się z jak największej ilości deklaratywnych funkcji bez żadnych skutków ubocznych. Imperatywne - mówisz maszynie jak ma coś zrobić (sumowanie tabelicy w pętli for) Deklaratywne - mówisz maszynie co ma zrobić dla ciebie (metoda .reduce() na tabeli) I wiele innych, które często mają pokrywające się definicje i zahaczają o podobne koncepty nt. tego jak powinno być tworzone oprogramowanie. Gramatyki bezkontekstowe – definicje, charakterystyki i przykłady. “Gramatyki bezkontekstowe są formalizmem służącym do opisu składni”. Inaczej jest to sposób na uproszczenie różnych języków i zapisanie ich w tej samej notacji (BNF). Dzieki temu języki o różnych składniach mogą być sprowadzone do tego samego zapisu, co pozwala na używanie tych samych narzędzi do analizy różnych języków.\nAnaliza leksykalna, syntaktyczna i semantyczna kodu. Analiza leksylana Proces rozbijania programów na jednostki logiczne (takie jak instrukcje sterujące, identyfikatory lub konkretne dane). Leks - ciąg znaków stanowiący semantycznie niepodzielną całość Żeton - stała reprezentująca rodzaj wczytanego tokenu Atrybut - opcjonalna wartość reprezentująca znaczenie tokenu\nAnaliza syntaktyczna Analizator syntaktyczny (parser) wykorzystuje efekt działania analizy leksykalnej (rozbite elementarne jednostki logiczne) i dokonuje analizy składniowej, w celu sprawdzenia czy dane mają właściwą strukturę.\nAnaliza semantyczna Analiza semantyczna służy upewnieniu się, że podany kod ma sens logiczny.\nRodzaje błędów w kontekście analizy leksykalnej, syntaktycznej i semantycznej kodu. Analiza leksylana użycie niewłaściwych leksów (ciąg znaków lub operacji, które nie istnieją) Analiza syntaktyczna błędy ‘składniowe’, brak operacji między zmiennymi Analiza semantyczna błędy logiczne, przypisanie wartości niewłaściwego typu, użycie niewłaściwego typu danych, kontrola ilości i typów parametrów i argumentów funkcji oraz metod Deklaratywne programowanie funkcyjne: rachunek lambda, monady. Rachunek lambda Monady Deklaratywne programowanie w logice: klauzule Horne’a, nawracanie. Klauzule Horne’a Nawracanie Podstawowe układy systemu mikroprocesorowego i sposób wymiany informacji pomiędzy nimi. Dekoder, multiplekser i demultiplekser: budowa, zasada, działania, przeznaczenie, zastosowanie. Kodowanie liczb ze znakiem w systemie U2, generowanie liczby ze znakiem przeciwnym, dodawanie i odejmowanie. Budowa i zasada działania generatora obrazu w systemie mikroprocesorowym. Mechanizm sesji w zarządzaniu stanem aplikacji sieciowej. Mechanizm gniazd – pojęcie, sposób realizacji i zastosowanie Metody obsługi wielu klientów równolegle w aplikacjach sieciowych. Zadania związane z obsługą ruchu w aplikacjach sieciowych zawsze mają duże opóźnienia związane z ciągłym czekaniem na odpowiedź. W zależności od wykorzystywanego języka można poradzić sobie z nimi na kilka sposobów.\ntworzenie zielonych wątków (wiele języków wprowadza własną definicję wątków) do obsługi zapytania wykorzystanie mechanizmów asynchronicznych (np pętla zdarzeń w JS lub async scheduler w RUST) Pocztowe protokoły warstwy aplikacji. SMPT, POP, IMAP\nPorównanie HTTP i WebSocket. HTTP służy do przesłania pakietu danych, websocket nawiązuje połącznie utrzymywane przez dłuższy okres czasu. Oba korzystają z TCP. WebSocket tworzy tunel i pozwala na przesyłanie wiadomości między dwoma komunikującymi się stronami, HTTP jest oparte o model ZAPYTANIE-\u003eODPOWIEDŹ.\nAtrybuty bezpieczeństwa informacji. Modele dystrybucji kluczy kryptograficznych. Rodzaje zagrożeń oraz ochrona aplikacji sieciowych. Charakterystyka kryptografii symetrycznej oraz asymetrycznej. ","wordCount":"3491","inLanguage":"en","datePublished":"2023-06-30T09:03:20-08:00","dateModified":"2023-06-30T09:03:20-08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://nxyt.pl/blog/posts/zagadnienia_umcs/"},"publisher":{"@type":"Organization","name":"just some developer thoughts","logo":{"@type":"ImageObject","url":"https://nxyt.pl/blog/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nxyt.pl/blog accesskey=h title="just some developer thoughts (Alt + H)">just some developer thoughts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Zagadnienia egzamin licencjacki UMCS Informatyka</h1><div class=post-meta><span title='2023-06-30 09:03:20 -0800 -0800'>June 30, 2023</span></div></header><div class=post-content><p>Krótka powtórka wiedzy wymaganej na obronie pracy licencjackiej na UMCS. Nie jest to wyczerpujące omówienie wszystkich problemów i osobiście polecałbym przeczytać cały ten post 1-2 razy, po czym poszukać materiałów bardziej szczegółowych do wybranych/cięższych tematów. Najzwyczajniej w świecie uznałem, że ucząc się zrobię krótkie podsumowanie każdego tematu tak, żeby mieć chociaż powierzchowne pojęcie na jego temat. Zebranie materiałów w jednym miejscu jest też dobre do utrwalania wiedzy. Proszę korzystać na własne ryzyko ( ͡° ͜ʖ ͡°)</p><h1 id=wektory-i-macierze--definicje-i-podstawowe-operacje>Wektory i macierze – definicje i podstawowe operacje.<a hidden class=anchor aria-hidden=true href=#wektory-i-macierze--definicje-i-podstawowe-operacje>#</a></h1><h2 id=wektory>Wektory<a hidden class=anchor aria-hidden=true href=#wektory>#</a></h2><p>Obiekt matematyczny opisywany za pomocą modułu (wartość), kierunku oraz zwrotu. Wektor w przestrzeni 2d przyjmuje postać pary punktów - na przykład [3, 4], co oznacza że aby stworzyć wektor w przestrzeni 2d należy ruszyć się o 3 punkty na osi X i 4 na osi Y.</p><p><img loading=lazy src=https://www.matemaks.pl/grafika/g0559.png alt=Wektory></p><h3 id=dodawanie-i-odejmowanie>Dodawanie i odejmowanie<a hidden class=anchor aria-hidden=true href=#dodawanie-i-odejmowanie>#</a></h3><p>Aby dodać lub odjąć dwa wektory wystarczy odjąć od siebie analogiczne wartości. [-10. 5] + [3, 2] = [-7, 7]</p><h3 id=mnożenie-i-dzielenie>Mnożenie i dzielenie<a hidden class=anchor aria-hidden=true href=#mnożenie-i-dzielenie>#</a></h3><p>Wektor można pomnożyć lub podzielić przez liczbę, co skutkuje zmianą obu wartości w wektorze. [4,3] * 2 = [8,6]</p><h3 id=iloczyn-skalarny>Iloczyn skalarny<a hidden class=anchor aria-hidden=true href=#iloczyn-skalarny>#</a></h3><p><code>[a1, b1] * [a2, b2] = a1 * a2 + b1 * b2</code>. Przykład: <code>[5,3] * [-1, 7] = 5*-1 + 3*7 = -5 + 21 = 16</code></p><h2 id=macierze>Macierze<a hidden class=anchor aria-hidden=true href=#macierze>#</a></h2><p>Macierz to układ liczb, symboli lub wyrażeń zapisany w prostokątnej tablicy. Macierze wykorzystywane są przykładowo do rozwiązywania równań liniowych.
<img loading=lazy src=https://eduinf.waw.pl/inf/prg/009_kurs_avr/images_t/0007.p1.gif alt="zdj macierzy"></p><h3 id=rozwiązywanie-równań-liniowych>Rozwiązywanie równań liniowych<a hidden class=anchor aria-hidden=true href=#rozwiązywanie-równań-liniowych>#</a></h3><h1 id=funkcje-skrótu-i-ich-zastosowanie>Funkcje skrótu i ich zastosowanie<a hidden class=anchor aria-hidden=true href=#funkcje-skrótu-i-ich-zastosowanie>#</a></h1><p>Funkcja przyporządkowująca dowolnej wartości, wartość o stałej długości. Funkcje skrótu (inaczej hashujące) wykorzystywane są w kryptografii, do tworzenia struktur danych (hashmapy), do oceny integralności danych (caching - sumy kontrolne pozwalają porównać zbiory danych bez porównywania znak po znaku).</p><h1 id=problemy-rekurencyjne>Problemy rekurencyjne<a hidden class=anchor aria-hidden=true href=#problemy-rekurencyjne>#</a></h1><p>Problemy rekurencyjne, to problemy które można rozwiązać korzystając z rekurencji, czyli można taki problem sprowadzić do postaci gdzie jego rozwiązanie zawiera w sobie swoją własną definicję. Przykładem może być ciąg Fibonacciego - <code>Fib(n) = Fib(n-1) + Fib(n-2)</code>. Każda funkcja wywołująca siebie samą jest rekurencyjna.
Inne problemy rekurencyjne to na przykład algorytmy typu dziel i rządź, gdzie zbiór danych jest dzielony, a następnie na obu połowach zbioru znowu wykonywany jest ten sam algorytm.</p><h1 id=podstawowe-charakterystyki-statystyki-opisowej-i-matematycznej>Podstawowe charakterystyki statystyki opisowej i matematycznej<a hidden class=anchor aria-hidden=true href=#podstawowe-charakterystyki-statystyki-opisowej-i-matematycznej>#</a></h1><h1 id=pozycyjne-systemy-liczbowe-i-konwersje-pomiędzy-nimi>Pozycyjne systemy liczbowe i konwersje pomiędzy nimi<a hidden class=anchor aria-hidden=true href=#pozycyjne-systemy-liczbowe-i-konwersje-pomiędzy-nimi>#</a></h1><p>Metoda zapisywania liczb, w której pozycja cyfry w ciągu oznacza wieloktorność potęgi bazy jaką dana cyfra reprezentuje. W systemie 10 liczba <code>121 = 1 * 10^2 + 2 * 10^1 + 1 * 1^0</code>. Potęgi bazy zaczynają się od 0 po prawej stronie i rosną o 1.
W innych systemach zmienia się wyłącznie wartość bazy. W systemie 5 liczba <code>434 = 4 * 5^2 + 3 * 5^1 + 4 * 5^0</code>. Zapisując liczbę w ten sposób można obliczyć jej wartość w systemie 10. Każdy system można więc łatwo zapisać w postaci dziesiętnej.
Aby zamienić system 10 na inny system należy dzielić liczbę przez bazę danego systemu i zapisywać resztę z dzielenia. 173 w systemie 6 to</p><pre tabindex=0><code>  173/6=28 reszta 5
  28/6=4   reszta 4
  4/6=0    reszta 4

  wynik w systemie szóstkowym = 445
</code></pre><h1 id=sposoby-cyfrowej-reprezentacji-liczby-całkowitej-i-rzeczywistej>Sposoby cyfrowej reprezentacji liczby całkowitej i rzeczywistej<a hidden class=anchor aria-hidden=true href=#sposoby-cyfrowej-reprezentacji-liczby-całkowitej-i-rzeczywistej>#</a></h1><h2 id=liczby-całkowite>Liczby całkowite<a hidden class=anchor aria-hidden=true href=#liczby-całkowite>#</a></h2><p>Liczba zapisywana jest w postaci binarnej. Typ liczby całkowitej (na przykład u8 - unsigned 8) oznacza ilość bitów wykorzystanych do reprezentacji liczby. Jeżeli liczba może być dodatnia lub ujemna należy wykorzystywać typ danych, w którym ostatni bit wykorzystywany jest do przechowywania informacji czy liczba jest dodatnia (jak i8).</p><h2 id=ujemne-liczby-całkowite>Ujemne liczby całkowite<a hidden class=anchor aria-hidden=true href=#ujemne-liczby-całkowite>#</a></h2><p>W przypadku typów, w których liczba może być ujemna najstarszy bit jest wykorzystywany do informowania o tym czy liczba jest ujemna. Aby zapisać liczbę w postaci ujemnej zapisz jej bezwzględną wartość w postaci binarnej, następnie odwróć wszystkie bity i dodaj 1.</p><pre tabindex=0><code>  -7 w systemie dziesiętnym
  1) zapisz jako 7 w systemie binarnym w zmiennej typu i8 (8 bitów)
  00000111
  2) odwróć bity
  11111000
  3) dodaj 1
  11111001
</code></pre><h2 id=liczby-dziesiętne>Liczby dziesiętne<a hidden class=anchor aria-hidden=true href=#liczby-dziesiętne>#</a></h2><p>Norma IEEE 754 stanowi standard zapisywania liczb całkowitych przy użyciu 32 lub 64 bitów.
Pierwszy bit podobnie jak w przypadku liczb całkowitych zapisywany jest do kodowania ujemnych liczb (tzn jeśli ma wartość 1 to liczba jest ujemna). Dalej 8/11 bitów koduje wykładnik (nie może składać sie z samych zer lub jedynek), czyli potęgę do jakiej należy podnieść znormalizowaną wartość liczby. Reszta bitów wykorzystywana jest do zapisu liczby w znormalizowanym formacie binarnym.</p><h1 id=typ-zmienna-obiekt-i-zarządzanie-pamięcią>Typ, zmienna, obiekt i zarządzanie pamięcią<a hidden class=anchor aria-hidden=true href=#typ-zmienna-obiekt-i-zarządzanie-pamięcią>#</a></h1><h2 id=typ>Typ<a hidden class=anchor aria-hidden=true href=#typ>#</a></h2><p>Typy danych niosą informacje na temat tego jak interpretowany powinien być dany wycinek pamięci. Ta sama sekwencja zer i jedynek może oznaczać różne rzeczy, zależnie od tego czy interpretowana jest jako liczba całkowita, zmiennoprzecinkowa lub znak tekstowy.</p><h2 id=zmienna>Zmienna<a hidden class=anchor aria-hidden=true href=#zmienna>#</a></h2><p>Konstrukt programistyczny składający się z nazwy symbolicznej, miejsce przechowywania oraz wartość.</p><h2 id=obiekt>Obiekt<a hidden class=anchor aria-hidden=true href=#obiekt>#</a></h2><p>Konstukt złożony z jednego lub więcej typów prostych danych. Przykładem obiektu jest instancja klasy w c++.</p><h1 id=instrukcje-sterujące-przepływem-programu>Instrukcje sterujące przepływem programu<a hidden class=anchor aria-hidden=true href=#instrukcje-sterujące-przepływem-programu>#</a></h1><p>Instrukcje sterujące zależą od wykorzystywanego języka, najczęstsze to:</p><ul><li>if</li><li>switch</li><li>while</li><li>for</li><li>while</li><li>do; while;</li><li>match</li><li>break</li><li>continue</li><li>goto</li></ul><h1 id=protokoły-tcp-i-udp--porównanie-i-zastosowanie>Protokoły TCP i UDP – porównanie i zastosowanie<a hidden class=anchor aria-hidden=true href=#protokoły-tcp-i-udp--porównanie-i-zastosowanie>#</a></h1><h2 id=tcp>TCP<a hidden class=anchor aria-hidden=true href=#tcp>#</a></h2><p>Priorytetem TCP (Transmission Control Protocol) jest stabilność i niezawodność. TCP wymaga nawiązania połączenia przed przesłaniem właściwych pakietów. Dzięki temu możliwe jest na przykład ponowne przesłanie pakietów, jeżeli nie trafiły one do miejsca docelowego. Dodatkowe zadania związane z nawiązaniem i utrzymaniem tego połączenia zwiększają opóźnienie oraz przepustowość.
TCP jest stosowane wszędzie tam gdzie wymagana jest komunikacja z pewnością, że dane dotrą do celu, czyli w większości aplikacji internetowych, stronach internetowych.</p><h2 id=udp>UDP<a hidden class=anchor aria-hidden=true href=#udp>#</a></h2><p>UDP (User Datagram Protocol) nie wymaga nawiązania wcześniejszego połączenia z klientem i od razu wysyła właściwe dane. Poza tym, że UDP nie wykonuje części czynności, nagłówki w tym protokole są również odpowiednio mniejsze (8 bajtów do 20-60 w TCP)
UDP wykorzystywane jest tam, gdzie potrzebne jest strumieniowanie danych w czasie rzeczywistym, korzystają z niego często gry komputerowe online.</p><p>Oba protokoły mają swój własny zestaw portów na komputerze, przykładowo jedna aplikacja może wykorzystywać port 420/tcp, inna 420/udp.</p><h1 id=adresowanie-w-warstwie-internetu-modelu-tcpip>Adresowanie w warstwie Internetu modelu TCP/IP<a hidden class=anchor aria-hidden=true href=#adresowanie-w-warstwie-internetu-modelu-tcpip>#</a></h1><p>Pakiety wysyłane w sieci muszą zawierać adres IP oraz numer portu na który wysyłany jest dany pakiet. Adres składa się z 4 liczb 0-255 (np 192.168.1.1), a port ma numer od 0 do 65535.</p><h1 id=porównanie-zadań-przełącznika-switcha-i-routera>Porównanie zadań przełącznika (switcha) i routera<a hidden class=anchor aria-hidden=true href=#porównanie-zadań-przełącznika-switcha-i-routera>#</a></h1><ul><li>Switch wykorzystuje adresy MAC, Router adresy IP</li><li>Switche obsługują tylko sieci przewodowe sieci LAN</li><li>Router pracuje w wyższej warstwie sieci niż switch</li><li>Switch przekazuje pakiety do nieznanych odbiorców wszystkich, router nie wysyła ich nigdzie</li></ul><h1 id=porównanie-modelu-osi-i-tcpip>Porównanie modelu OSI i TCP/IP<a hidden class=anchor aria-hidden=true href=#porównanie-modelu-osi-i-tcpip>#</a></h1><ul><li>model tcp/ip ma 4 warstwy, OSI 7</li><li>warstwy TCP/IP to warstwa: aplikacji, transportu, internetowa, dostępu do sieci</li><li>warstwy OSI to: aplikacji, prezentacji, sesji, transportowa, sieciowa, łącza danych, fizyczna</li><li>warstwy OSI aplikacji, prezentacji oraz sesji odpowiadają jednej warstwie aplikacji modelu TCP/IP</li><li>warstwa dostępu do sieci modelu TCP/IP zawiera w sobie dwie warstwy OSI: łącza danych oraz fizyczną</li></ul><h1 id=mechanizm-enkapsulacji-w-modelu-osi>Mechanizm enkapsulacji w modelu OSI<a hidden class=anchor aria-hidden=true href=#mechanizm-enkapsulacji-w-modelu-osi>#</a></h1><p>Ruch sieciowy przekazywany jest do niższych warstw, gdzie pakiety są obudowywane w ramki wymagane przez daną warstwę. Przykładowo warstwa aplikacji przy obudowaniu w warstwę transportową zawiera ramki z wymaganymi adresami odbiorcy.</p><h1 id=obiekt-i-klasa-w-wybranym-języku-programowania-zorientowanym-obiektowo>Obiekt i klasa w wybranym języku programowania zorientowanym obiektowo<a hidden class=anchor aria-hidden=true href=#obiekt-i-klasa-w-wybranym-języku-programowania-zorientowanym-obiektowo>#</a></h1><p>Javascript:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Rect</span> {
</span></span><span style=display:flex><span><span style=color:#a6e22e>constructor</span>(<span style=color:#a6e22e>height</span>, <span style=color:#a6e22e>width</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>height</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>width</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Getter
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>get</span> <span style=color:#a6e22e>area</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>calcArea</span>();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Method
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#a6e22e>calcArea</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>height</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#f92672>*</span><span style=color:#a6e22e>getSides</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>height</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>height</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>yield</span> <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>width</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>square</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Rectangle</span>(<span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>);
</span></span></code></pre></div><p>Co tu gadać, koń jaki jest każdy widzi. Klasa definiuje kształ obiektów danego typu, po czym obiekty tworzy się korzystając ze słowa <code>new</code>.</p><h1 id=hermetyzacja-dziedziczenie-i-polimorfizm-w-programowaniu-obiektowym>Hermetyzacja, dziedziczenie i polimorfizm w programowaniu obiektowym.<a hidden class=anchor aria-hidden=true href=#hermetyzacja-dziedziczenie-i-polimorfizm-w-programowaniu-obiektowym>#</a></h1><h2 id=hermetyzacja-enkapsulacja>Hermetyzacja (enkapsulacja)<a hidden class=anchor aria-hidden=true href=#hermetyzacja-enkapsulacja>#</a></h2><p>Ograniczanie dostępu do pól/metod zewnętrznym obiektom. Enkapsulacja pozwala na podejmowanie decyzji nt. tego jak konsumenci mają korzystać z danego API. Przykładem enkapsulacji jest stworzenie klasy, która ma 2 metody publiczne i więcej metod prywatnych. Prywatne metody mogą być wykorzystywane w definicjach publicznych metod, ale nie mogą być wywołane bezpośrednio przez użytkownika.</p><h2 id=dziedziczenie>Dziedziczenie<a hidden class=anchor aria-hidden=true href=#dziedziczenie>#</a></h2><p>Dziedziczenie pozwala na rozbudowywanie klasy bazowej o nowe pola oraz metody. Szczegóły zależą od konkretnego języka. Z zasady klasy dziedziczące zawierają się w zbiorze klasy bazowej, mogą być więc używane polimorficznie.</p><h2 id=polimorfizm>Polimorfizm<a hidden class=anchor aria-hidden=true href=#polimorfizm>#</a></h2><p>Możliwość wykorzystywania obiektów różnych typów w ten sam sposób. Przykładem mogą być klasy dziedziczące, które mogą być wykorzystywane w miejscu klasy bazowej. Innym przykładem polimorfizmu są interfejsy, które mogą być implementowane przez różne klasy. Jeśli obiekty różnych klas implementują ten sam interfejs, to mogą być wykorzystywane polimorficznie.</p><h1 id=interfejsy-i-klasy-abstrakcyjne-w-programowaniu-obiektowym>Interfejsy i klasy abstrakcyjne w programowaniu obiektowym<a hidden class=anchor aria-hidden=true href=#interfejsy-i-klasy-abstrakcyjne-w-programowaniu-obiektowym>#</a></h1><p>Klasa abstrakcyjna, to klasa która nie może mieć żadnej instancji. Taka klasa dalej może mieć metody statyczne. Interfejsy to forma kontraktu w której często specyfikowana jest tylko sygnatura funkcji i zwracany typ danych.</p><h1 id=paradygmat-i-przykłady-programowania-generycznego-rodzajowego>Paradygmat i przykłady programowania generycznego (rodzajowego)<a hidden class=anchor aria-hidden=true href=#paradygmat-i-przykłady-programowania-generycznego-rodzajowego>#</a></h1><p>Programowanie generyczne to rodzaj metaprogramowania, gdzie celem jest stworzenie generycznych metod, które mogą działać na różnych typach danych. Zależnie od języka umożliwiane jest to na różne sposoby. C++ wykorzystuje szablony, Java, C#, Typescript, Rust typy generyczne, a Zig (mniej znany język) Comptime (kod Zig, działający na etapie kompilacji, nie w runtime).</p><h1 id=algorytmy-sortowania>Algorytmy sortowania<a hidden class=anchor aria-hidden=true href=#algorytmy-sortowania>#</a></h1><p>Algorytmy sortowania mają różną złożoność czasową i wymaganiami co do pamięci wymaganej do przeprowadzenia sortowania. Algorytmy typu bubble sort mają O(n^2), a quicksort oraz mergesort O(n log(n)). Jest nieskończenie wiele sposobów na posortowanie ciągu wartości, więc opiszę na szybko tylko dwa wydajne algorytmy - mergesort i quicksort.
Quicksort dzieli tablicę na dwie części, elementy mniejsze od wybranego pivota (elementu dzielącego tablicę) przerzuca na lewo, większe na prawo. Następnie na obu częściach wykonywany jest quicksort.
Mergesort dzieli tablicę na dwie części, a dopiero później łączy je w większe tablice. Różnice w praktyce jest taka, że mergesort najpierw rekursyjnie rozbija problem aż do samego dołu (aż do tablic o rozmiarze 1) i sortuje w trakcie łączenia, quicksort natomiast sortuje połówki tablic, aż cała tablica będzie posortowana.</p><h1 id=strategia-dziel-i-zwyciężaj-budowania-algorytmów>Strategia „dziel i zwyciężaj” budowania algorytmów<a hidden class=anchor aria-hidden=true href=#strategia-dziel-i-zwyciężaj-budowania-algorytmów>#</a></h1><p>Strategia ta dzieli problem na mniejsze problemy tego samego typu, rozwiązuje je rekursyjnie, po czym scala rozwiązania.
Przykłady: quicksort, mergesort, binary search</p><h1 id=algorytmy-typu-zachłannego>Algorytmy typu zachłannego<a hidden class=anchor aria-hidden=true href=#algorytmy-typu-zachłannego>#</a></h1><p>Algorytm, który w każdym kroku dokonuje decyzji lokalnie optymalnej, czyli takiej która wydaje się najlepsza w danym kroku. Przykładem może być algorytm Dijkstry,</p><h1 id=algorytmy-z-nawrotami>Algorytmy z nawrotami<a hidden class=anchor aria-hidden=true href=#algorytmy-z-nawrotami>#</a></h1><p>Algorytmy, które tworzą drzewo rozwiązań. Jeśli nie spełniają określonego warunku lub trafią na sekwencję opracowaną w przeszłości wracają do innej ścieżki drzewa rozwiązań.</p><h1 id=grafy-drzewa-kopce--charakterystyka-i-przykłady-zastosowania>Grafy, drzewa, kopce – charakterystyka i przykłady zastosowania<a hidden class=anchor aria-hidden=true href=#grafy-drzewa-kopce--charakterystyka-i-przykłady-zastosowania>#</a></h1><h2 id=grafy>Grafy<a hidden class=anchor aria-hidden=true href=#grafy>#</a></h2><p>Graf to zbiór wierchołków (węzłów) oraz krawędzi. Krawędzie mogą być skierowane, czyli pozwalać na ruch tylko w jedną stronę np: A -> B - możesz z A przejść do B, ale nie odwrotnie. Krawędzie nieskierowane (A &ndash; B) pozwalają na ruch w obie strony.</p><h2 id=drzewa>Drzewa<a hidden class=anchor aria-hidden=true href=#drzewa>#</a></h2><p>Drzewo to specjalny rodzaj grafu, który zaczyna sie od jednego źródła (root), a każdy węzeł łączy się tylko ze swoim rodzicem i z 0 lub więcej dzieci.</p><h2 id=kopce>Kopce<a hidden class=anchor aria-hidden=true href=#kopce>#</a></h2><p>Kopiec to drzewo, gdzie wartości dziecka są w stałej relacji z wartością rodzica. Inaczej, drzewo układa dane według pewnej hierarchii semantycznej, kopiec według wartości.</p><h1 id=wielowarstwowa-organizacja-systemów-komputerowych>Wielowarstwowa organizacja systemów komputerowych<a hidden class=anchor aria-hidden=true href=#wielowarstwowa-organizacja-systemów-komputerowych>#</a></h1><p>Od najniższej:</p><ul><li>warstwa sprzętowa - wszystkie komponenty i peryferia PC</li><li>system operacyjny - pozwala na kontakt między użytkownikiem a sprzętem</li><li>oprogramowanie narzędziowe - sterowniki i programy potrzebne do funkcjonowania systemu</li><li>oprogramowanie użytkowe - reszta programów</li><li>użytkownik - człowiek lub inna maszyna konsumująca oprogramowanie</li></ul><h1 id=system-operacyjny--charakterystyka-zadania-klasyfikacja>System operacyjny – charakterystyka, zadania, klasyfikacja<a hidden class=anchor aria-hidden=true href=#system-operacyjny--charakterystyka-zadania-klasyfikacja>#</a></h1><p>System operacyjny zajmuje się:</p><ul><li>planowaniem i przydziałem zasobów</li><li>synchronizacją i komunikacją procesów</li><li>obsługuje warstwę sprzętową</li></ul><p>Jest <a href=http://smurf.mimuw.edu.pl/node/871>wiele różnych</a> klasyfikacji systemów operacyjnych: ze względu na liczbę wykonywanych programów, sposób przetwarzania itd. Szczerze to mało ciekawe klasyfikacje, które wydają mi się zbędną abstrakcją więc nie będę rozwijał tutaj tematu.</p><h1 id=procesy-i-wątki--charakterystyka-i-problemy>Procesy i wątki – charakterystyka i problemy<a hidden class=anchor aria-hidden=true href=#procesy-i-wątki--charakterystyka-i-problemy>#</a></h1><p>Proces, to pewien program wykonywany w systemie, który dostał pulę zasobów do wykorzystania. W obrębie jednego procesu może znajdować się wiele wątków, które mogą być wykonywane równolegle lub na zmianę. Wątki są lżejsze od procesów i program może bez problemu stworzyć wiele tysięcy różnych wątków.</p><h1 id=zarządzanie-pamięcią-operacyjną-w-systemie-operacyjnym>Zarządzanie pamięcią operacyjną w systemie operacyjnym.<a hidden class=anchor aria-hidden=true href=#zarządzanie-pamięcią-operacyjną-w-systemie-operacyjnym>#</a></h1><p>Programy korzystają z API systemu operacyjnego do alokowania i uwalniania potrzebnej pamięci. Przy wywołaniu odpowiedniego API system szuka wolnego miejsca. Szukanie wolnego miejsca może odbywać się korzystając z jednej z wielu różnych strategii (m.in. pierwsze wolne, najlepsze).</p><h1 id=organizacja-systemu-plików-i-pamięci-zewnętrznej>Organizacja systemu plików i pamięci zewnętrznej.<a hidden class=anchor aria-hidden=true href=#organizacja-systemu-plików-i-pamięci-zewnętrznej>#</a></h1><p>Systemy plików NFTS/FAT32/EXT4?</p><h1 id=różnice-pomiędzy-obsługą-zdarzeń-w-przerwaniach-sprzętowych-a-obsługą-zdarzeń-w-pętli-programowej>Różnice pomiędzy obsługą zdarzeń w przerwaniach sprzętowych a obsługą zdarzeń w pętli programowej.<a hidden class=anchor aria-hidden=true href=#różnice-pomiędzy-obsługą-zdarzeń-w-przerwaniach-sprzętowych-a-obsługą-zdarzeń-w-pętli-programowej>#</a></h1><p>Obsługiwanie zdarzeń w pętli programowej jest mało wydajne, ponieważ wymaga ciągłego sprawdzania bitów związanych z danymi wydarzeniami. System nie reaguje bezpośrednio na zdarzenie, tylko czeka aż program dojdzie do danego fragmentu kodu sprawdzającego stan flagi. Prowadzi to do większych opóźnień w reakcji na bodziec.
Metoda przerwań polega na tym, że to układy zgłaszają do jednostki centralnej potrzebę obsługi (w przeciwieństwie do pętli programowej gdzie system sprawdza stan układów). Gdy takie zdarzenie ma miejsce system przerywa aktualnie wykonywany kod i zaczyna obsługiwać dane wydarzenie.</p><h1 id=powody-i-przykłady-stosowania-mikrokontrolerów-zamiast-typowych-komputerów>Powody i przykłady stosowania mikrokontrolerów zamiast typowych komputerów.<a hidden class=anchor aria-hidden=true href=#powody-i-przykłady-stosowania-mikrokontrolerów-zamiast-typowych-komputerów>#</a></h1><p>Powody:</p><ul><li>niższa cena</li><li>mniej ruchomych części (tzn brak systemu, który może wprowadzać całą nową klasę błędów)</li><li>mniejsze zużycie prądu</li></ul><p>Przykłady:</p><ul><li>urządzenia RTV/AGD</li><li>prosta elektronika</li></ul><h1 id=modele-reprezentacji-wiedzy>Modele reprezentacji wiedzy.<a hidden class=anchor aria-hidden=true href=#modele-reprezentacji-wiedzy>#</a></h1><p><a href=http://staff.iiar.pwr.wroc.pl/dariusz.banasiak/si/SI_w5_notatki.pdf>Źródło</a></p><h1 id=mechanizmy-wnioskowań>Mechanizmy wnioskowań.<a hidden class=anchor aria-hidden=true href=#mechanizmy-wnioskowań>#</a></h1><p>Wnioskowanie wstecz - wykazanie prawdziwości hipotezy na podstawie prawdziwości przesłanek.
Wnioskowanie wprzód - na podstawie prawdziwych faktów tworzone są nowe prawdziwe twierdzenia. Nowe twierdzenia mogę generować nowe wnioski. Proces jest powtarzany aż dojdzie się do zakładanej hipotezy lub aż skończą się nowe fakty.
Metoda rezolucji - dowodzenie przez zaprzeczenie.</p><h1 id=metody-uczenia-maszynowego>Metody uczenia maszynowego.<a hidden class=anchor aria-hidden=true href=#metody-uczenia-maszynowego>#</a></h1><ul><li>Uczenie nadzorowane - uczenie następuje w wyniku porównania wyników programu z prawidłowymi odpowiedziami.</li><li>Uczenie nienadzorowane -</li><li>Uczenie ze wzmocnieniem - uczenie następuje w wyniku reakcji na dane ze środowiska.</li></ul><h1 id=budowa-sieci-neuronowych>Budowa sieci neuronowych.<a hidden class=anchor aria-hidden=true href=#budowa-sieci-neuronowych>#</a></h1><p>Sieci neuronowe składają się z jednej lub więcej warstw neuronów, z których każdy ma pewien próg aktywacji.</p><h1 id=normalizacja-baz-danych--pierwsza-druga-i-trzecia-postać-normalna>Normalizacja baz danych – pierwsza, druga i trzecia postać normalna.<a hidden class=anchor aria-hidden=true href=#normalizacja-baz-danych--pierwsza-druga-i-trzecia-postać-normalna>#</a></h1><h2 id=pierwsza-postać-normalna>Pierwsza postać normalna<a hidden class=anchor aria-hidden=true href=#pierwsza-postać-normalna>#</a></h2><ul><li>wiersz opisuje jeden obiekt</li><li>wszystkie kolumny zawierają wartości elementarne/skalarne</li><li>nie zawiera powtórzeń informacji na temat obiektu</li><li>kolejność wierszy może być dowolna</li></ul><h2 id=druga-postać-normalna>Druga postać normalna<a hidden class=anchor aria-hidden=true href=#druga-postać-normalna>#</a></h2><ul><li>&ldquo;Relacja jest w drugiej postaci normalnej wtedy i tylko wtedy, gdy jest w I postaci normalnej i żadna kolumna niekluczowa nie jest częściowo funkcyjnie zależna od jakiegokolwiek klucza potencjalnego&rdquo; - nie pytaj
A tak serio: chodzi o to że tabela nie zawiera informacji, które możesz wywnioskować z klucza potencjalnego. Jeśli masz tabelę gdzie są imiona i płcie osób, to przy założeniu że imie jest przypisane do konkretnej płci, informacja o płci jest powtórzeniem danych - możesz ją wywnioskować z klucza potencjalnego (imienia), więc nie jest to druga postać normalna.</li></ul><h2 id=trzecia-postać-normalna>Trzecia postać normalna<a hidden class=anchor aria-hidden=true href=#trzecia-postać-normalna>#</a></h2><ul><li>&ldquo;Relacja jest w trzeciej postaci normalnej wtedy i tylko wtedy, gdy jest w II postaci normalnej i żaden atrybut niekluczowy nie jest zależny funkcyjnie od innych atrybutów niekluczowych&rdquo; - też nie pytaj
Znowu bardziej serio: żadna kolumna ma nie być do wywnioskowania z żadnej innej kolumny. Przechowujemy tylko informacje unikalne i jest git.</li></ul><h1 id=modele-baz-danych-logiczny-relacyjny-fizyczny>Modele baz danych (logiczny, relacyjny, fizyczny).<a hidden class=anchor aria-hidden=true href=#modele-baz-danych-logiczny-relacyjny-fizyczny>#</a></h1><p><a href=https://dbadmin.net.pl/model-logiczny-baz-danych-jak-dziala-model-danych/>Źródło</a></p><h2 id=logiczny>Logiczny<a hidden class=anchor aria-hidden=true href=#logiczny>#</a></h2><p>Model obiektów i relacji między danymi obiektami.</p><h2 id=relacyjny>Relacyjny<a hidden class=anchor aria-hidden=true href=#relacyjny>#</a></h2><p>Dane pogrupowane są w relacje reprezentowane przez tabele. Osobiście rozumiem to jako model logiczny, tylko rozbity do postaci normalnej.</p><h2 id=fizyczny>Fizyczny<a hidden class=anchor aria-hidden=true href=#fizyczny>#</a></h2><p>Implementacja modelu logicznego w komputerze.</p><h1 id=rodzaje-zapytań-w-języku-sql>Rodzaje zapytań w języku SQL.<a hidden class=anchor aria-hidden=true href=#rodzaje-zapytań-w-języku-sql>#</a></h1><p>SELECT, INSERT, DELETE, UPDATE - robią to co sugerują ich nazwy</p><h1 id=funkcje-w-języku-sql>Funkcje w języku SQL.<a hidden class=anchor aria-hidden=true href=#funkcje-w-języku-sql>#</a></h1><p>Przykład funkcji SQL w Postgres</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>FUNCTION</span> <span style=color:#66d9ef>add</span>(a integer, b integer) <span style=color:#66d9ef>RETURNS</span> integer
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>LANGUAGE</span> <span style=color:#66d9ef>SQL</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>IMMUTABLE</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>RETURNS</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>ON</span> <span style=color:#66d9ef>NULL</span> <span style=color:#66d9ef>INPUT</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>RETURN</span> a <span style=color:#f92672>+</span> b;
</span></span></code></pre></div><h1 id=transakcje-w-bazach-danych>Transakcje w bazach danych.<a hidden class=anchor aria-hidden=true href=#transakcje-w-bazach-danych>#</a></h1><p>Wiele operacji w bazach danych mogą być przeprowadzane w obrębie jednej transakcji. Jeśli na którymś kroku transakcja nie powiedzie się, to wszystkie wprowadzone wcześniej zmiany zostaną cofnięte.</p><h1 id=standardowe-metodyki-procesu-wytwórczego-oprogramowania>Standardowe metodyki procesu wytwórczego oprogramowania.<a hidden class=anchor aria-hidden=true href=#standardowe-metodyki-procesu-wytwórczego-oprogramowania>#</a></h1><ul><li>model kaskadowy - &ldquo;Obejmuje on pięć głównych czynności, które wykonywane są tylko raz w procesie tworzenia: definiowanie i analizowanie wymagań, projektowanie oprogramowania, implementację i testowanie jednostek, integrację i testowanie systemu oraz wdrożenie
i pielęgnację.&rdquo;</li><li>model ewolucyjny - stworzenie prototypu, danie go użytkownikowi i tworzenie nowych iteracji oprogramowania na podstawie zebranego feedbacku</li><li>metody zwinne - metodyki zwinne mają dobrze funkcjonować w zmieniającym się środowisku (na przykład przy niezbyt dobrze zdefiniowanych wymaganiach dla projektu)</li></ul><h1 id=metodyki-zwinne--scrum>Metodyki zwinne – SCRUM.<a hidden class=anchor aria-hidden=true href=#metodyki-zwinne--scrum>#</a></h1><p>SCRUM, metodyka zwinna tworzenia oprogramowania oparta o koncepcję sprintów. Najpierw planowany jest sprint (zakres prac), następnie miejsce ma sprint (najdłuższy etap, bo robiona jest prawdziwa robota), w trakcie sprintu codziennie miejsce mają spotkania scrumowe gdzie każdy bardzo krótko mówi na jakim etapie prac jest i co zamierza zrobić w ciągu najbliższego czasu. Pod koniec sprintu miejsce ma jego przegląd, gdzie kontrolowane są postępy zrobione w trakcie sprintu i wyniki przedstawiane są interesariuszom. Ostatnim etapem jest retrospektywa, w trakcie której zespół może ocenić sprint i podzielić się wiedzą, która może sprawdzić, że kolejne sprinty przebiegną jeszcze sprawniej.</p><h1 id=testowanie-oprogramowania>Testowanie oprogramowania.<a hidden class=anchor aria-hidden=true href=#testowanie-oprogramowania>#</a></h1><p>Testy automatyczne, manualne, CICD pipeline. Szeroki temat i ciężko powiedzieć co może interesować atakujących pracę :P W skrócie - testy automatyczne to testy, które kodujesz sam (na przykład przy użyciu frameworków e2e jak cypress/playwright), testy manualne są wtedy jak płacisz komuś z indii, żeby klikał w <code>buttona</code> i sprawdzał co się dzieje. CICD to rozwinięcie testów automatycznych, gdzie są one uruchamiane przy wrzuceniu kodu i w reakcji na wynik testów może następować aktualizacja aplikacji.</p><h1 id=diagramy-uml>Diagramy UML.<a hidden class=anchor aria-hidden=true href=#diagramy-uml>#</a></h1><p>Jak ktoś lubi rysować zamiast programować to można.</p><h1 id=wzorce-projektowe-programowania-obiektowego>Wzorce projektowe programowania obiektowego.<a hidden class=anchor aria-hidden=true href=#wzorce-projektowe-programowania-obiektowego>#</a></h1><p><a href=https://www.oodesign.com/>Źródło</a> - wzorców jest dużo, więc rzucę sam link. Najważniejsze to: singleton, strategia, fabryka, builder, obserwator, dekorator. Mimo wszystko warto kojarzyć więcej.</p><h1 id=definicja-funkcji-obliczalnej-częściowo-rekurencyjnej>Definicja funkcji obliczalnej (częściowo rekurencyjnej).<a hidden class=anchor aria-hidden=true href=#definicja-funkcji-obliczalnej-częściowo-rekurencyjnej>#</a></h1><p>&ldquo;funkcja o argumentach i wartościach w zbiorze liczb naturalnych (lub w zbiorze tekstów), dla której można podać algorytm znajdujący wartość funkcji na podstawie danego argumentu&rdquo;.
Prościej - funkcja obliczalna to funkcja, którą może &lsquo;rozwiązać&rsquo; maszyna turinga. Po co komplikują świrusy nie wiem.</p><p>Bonus: &ldquo;Funkcja f (x1, . . . , xn) jest częściowo rekurencyjna, jeśli może być
otrzymana z funkcji prostych za pomocą skończonej liczby zastosowań
operacji złożenia, rekursji prostej oraz minimum efektywnego.&rdquo;</p><h1 id=maszyna-turinga-jako-model-procesów-obliczalnych>Maszyna Turinga jako model procesów obliczalnych.<a hidden class=anchor aria-hidden=true href=#maszyna-turinga-jako-model-procesów-obliczalnych>#</a></h1><p><a href="https://wazniak.mimuw.edu.pl/index.php?title=Z%C5%82o%C5%BCono%C5%9B%C4%87_obliczeniowa/Wyk%C5%82ad_1:_Obliczenia_w_modelu_maszyny_Turinga">dobre źródło</a>
Maszyna turinga składa się z:</p><ul><li>nieskończonej taśmy z danymi wejściowymi (odpowiednik pamięci komputera). Może zawierać dowolne symbole, ale zwykle są to 0 i 1.</li><li>głowica zapisująco odczytująca - może odczytywać i zapisywać symbole oraz poruszać się wzdłuż taśmy</li><li>układ sterowania głowicą (odpowiednik procesora) - reaguje na dane odczytane przez głowicę i wysyła do niej kolejne polecenia</li></ul><p>Maszyna Turinga jest w stanie rozwiązać wszystkie problemy obliczalne, jeśli więc udowodni się że jakiś problem nie może być rozwiązany przez maszynę turinga, nie należy on do kategorii problemów obliczalnych (nie mogą go rozwiązać nasze komputery).</p><h1 id=zagadnienia-nierostrzygalne-w-kontekście-obliczalności>Zagadnienia nierostrzygalne w kontekście obliczalności.<a hidden class=anchor aria-hidden=true href=#zagadnienia-nierostrzygalne-w-kontekście-obliczalności>#</a></h1><p>Są zagadnienia, dla których udowodniono, że należą do grupy problemów nierozstrzygalnych: np. <a href=https://www.codingninjas.com/studio/library/halting-problem-in-the-theory-of-computation>problem stopu</a>.</p><h1 id=definicja-i-klasy-złożoności-obliczeniowej--czasowej-i-pamięciowej>Definicja i klasy złożoności obliczeniowej – czasowej i pamięciowej.<a hidden class=anchor aria-hidden=true href=#definicja-i-klasy-złożoności-obliczeniowej--czasowej-i-pamięciowej>#</a></h1><p><a href="https://wazniak.mimuw.edu.pl/index.php?title=Z%C5%82o%C5%BCono%C5%9B%C4%87_obliczeniowa/Wyk%C5%82ad_3:_Klasy_z%C5%82o%C5%BCono%C5%9Bci_obliczeniowej#Klasy_z.C5.82o.C5.BCono.C5.9Bci_czasowej_i_pami.C4.99ciowej">źródło</a>
W skrócie, klasy złożoności oznaczają zbiór języków spełniających wymagania stawiane przez daną maszynę turinga (SPACE, TIME, NSPACE, NTIME).</p><h1 id=główne-paradygmaty-programowania--charakterystyka-i-przykłady>Główne paradygmaty programowania – charakterystyka i przykłady.<a hidden class=anchor aria-hidden=true href=#główne-paradygmaty-programowania--charakterystyka-i-przykłady>#</a></h1><ul><li>Obiektowe - program składa się z obiektów i ich wzajemnych oddziaływań. To one są centralnym elementem aplikacji.</li><li>Funkcyjne - programowanie czerpiące z deklaratywnego paradygmatu programowania. Program powinien składać się z jak największej ilości deklaratywnych funkcji bez żadnych skutków ubocznych.</li><li>Imperatywne - mówisz maszynie jak ma coś zrobić (sumowanie tabelicy w pętli for)</li><li>Deklaratywne - mówisz maszynie co ma zrobić dla ciebie (metoda .reduce() na tabeli)
I wiele innych, które często mają pokrywające się definicje i zahaczają o podobne koncepty nt. tego jak powinno być tworzone oprogramowanie.</li></ul><h1 id=gramatyki-bezkontekstowe--definicje-charakterystyki-i-przykłady>Gramatyki bezkontekstowe – definicje, charakterystyki i przykłady.<a hidden class=anchor aria-hidden=true href=#gramatyki-bezkontekstowe--definicje-charakterystyki-i-przykłady>#</a></h1><p>&ldquo;Gramatyki bezkontekstowe są formalizmem służącym do opisu składni&rdquo;. Inaczej jest to sposób na uproszczenie różnych języków i zapisanie ich w tej samej notacji (BNF). Dzieki temu języki o różnych składniach mogą być sprowadzone do tego samego zapisu, co pozwala na używanie tych samych narzędzi do analizy różnych języków.</p><h1 id=analiza-leksykalna-syntaktyczna-i-semantyczna-kodu>Analiza leksykalna, syntaktyczna i semantyczna kodu.<a hidden class=anchor aria-hidden=true href=#analiza-leksykalna-syntaktyczna-i-semantyczna-kodu>#</a></h1><h2 id=analiza-leksylana>Analiza leksylana<a hidden class=anchor aria-hidden=true href=#analiza-leksylana>#</a></h2><p>Proces rozbijania programów na jednostki logiczne (takie jak instrukcje sterujące, identyfikatory lub konkretne dane).
Leks - ciąg znaków stanowiący semantycznie niepodzielną całość
Żeton - stała reprezentująca rodzaj wczytanego tokenu
Atrybut - opcjonalna wartość reprezentująca znaczenie tokenu</p><h2 id=analiza-syntaktyczna>Analiza syntaktyczna<a hidden class=anchor aria-hidden=true href=#analiza-syntaktyczna>#</a></h2><p>Analizator syntaktyczny (parser) wykorzystuje efekt działania analizy leksykalnej (rozbite elementarne jednostki logiczne) i dokonuje analizy składniowej, w celu sprawdzenia czy dane mają właściwą strukturę.</p><h2 id=analiza-semantyczna>Analiza semantyczna<a hidden class=anchor aria-hidden=true href=#analiza-semantyczna>#</a></h2><p>Analiza semantyczna służy upewnieniu się, że podany kod ma sens logiczny.</p><h1 id=rodzaje-błędów-w-kontekście-analizy-leksykalnej-syntaktycznej-i-semantycznej-kodu>Rodzaje błędów w kontekście analizy leksykalnej, syntaktycznej i semantycznej kodu.<a hidden class=anchor aria-hidden=true href=#rodzaje-błędów-w-kontekście-analizy-leksykalnej-syntaktycznej-i-semantycznej-kodu>#</a></h1><h2 id=analiza-leksylana-1>Analiza leksylana<a hidden class=anchor aria-hidden=true href=#analiza-leksylana-1>#</a></h2><ul><li>użycie niewłaściwych leksów (ciąg znaków lub operacji, które nie istnieją)</li></ul><h2 id=analiza-syntaktyczna-1>Analiza syntaktyczna<a hidden class=anchor aria-hidden=true href=#analiza-syntaktyczna-1>#</a></h2><ul><li>błędy &lsquo;składniowe&rsquo;, brak operacji między zmiennymi</li></ul><h2 id=analiza-semantyczna-1>Analiza semantyczna<a hidden class=anchor aria-hidden=true href=#analiza-semantyczna-1>#</a></h2><ul><li>błędy logiczne, przypisanie wartości niewłaściwego typu, użycie niewłaściwego typu danych, kontrola ilości i typów parametrów i argumentów funkcji oraz metod</li></ul><h1 id=deklaratywne-programowanie-funkcyjne-rachunek-lambda-monady>Deklaratywne programowanie funkcyjne: rachunek lambda, monady.<a hidden class=anchor aria-hidden=true href=#deklaratywne-programowanie-funkcyjne-rachunek-lambda-monady>#</a></h1><h2 id=rachunek-lambda>Rachunek lambda<a hidden class=anchor aria-hidden=true href=#rachunek-lambda>#</a></h2><h2 id=monady>Monady<a hidden class=anchor aria-hidden=true href=#monady>#</a></h2><h1 id=deklaratywne-programowanie-w-logice-klauzule-hornea-nawracanie>Deklaratywne programowanie w logice: klauzule Horne&rsquo;a, nawracanie.<a hidden class=anchor aria-hidden=true href=#deklaratywne-programowanie-w-logice-klauzule-hornea-nawracanie>#</a></h1><h2 id=klauzule-hornea>Klauzule Horne&rsquo;a<a hidden class=anchor aria-hidden=true href=#klauzule-hornea>#</a></h2><h2 id=nawracanie>Nawracanie<a hidden class=anchor aria-hidden=true href=#nawracanie>#</a></h2><h1 id=podstawowe-układy-systemu-mikroprocesorowego-i-sposób-wymiany-informacji-pomiędzy-nimi>Podstawowe układy systemu mikroprocesorowego i sposób wymiany informacji pomiędzy nimi.<a hidden class=anchor aria-hidden=true href=#podstawowe-układy-systemu-mikroprocesorowego-i-sposób-wymiany-informacji-pomiędzy-nimi>#</a></h1><h1 id=dekoder-multiplekser-i-demultiplekser-budowa-zasada-działania-przeznaczenie-zastosowanie>Dekoder, multiplekser i demultiplekser: budowa, zasada, działania, przeznaczenie, zastosowanie.<a hidden class=anchor aria-hidden=true href=#dekoder-multiplekser-i-demultiplekser-budowa-zasada-działania-przeznaczenie-zastosowanie>#</a></h1><h1 id=kodowanie-liczb-ze-znakiem-w-systemie-u2-generowanie-liczby-ze-znakiem-przeciwnym-dodawanie-i-odejmowanie>Kodowanie liczb ze znakiem w systemie U2, generowanie liczby ze znakiem przeciwnym, dodawanie i odejmowanie.<a hidden class=anchor aria-hidden=true href=#kodowanie-liczb-ze-znakiem-w-systemie-u2-generowanie-liczby-ze-znakiem-przeciwnym-dodawanie-i-odejmowanie>#</a></h1><h1 id=budowa-i-zasada-działania-generatora-obrazu-w-systemie-mikroprocesorowym>Budowa i zasada działania generatora obrazu w systemie mikroprocesorowym.<a hidden class=anchor aria-hidden=true href=#budowa-i-zasada-działania-generatora-obrazu-w-systemie-mikroprocesorowym>#</a></h1><h1 id=mechanizm-sesji-w-zarządzaniu-stanem-aplikacji-sieciowej>Mechanizm sesji w zarządzaniu stanem aplikacji sieciowej.<a hidden class=anchor aria-hidden=true href=#mechanizm-sesji-w-zarządzaniu-stanem-aplikacji-sieciowej>#</a></h1><h1 id=mechanizm-gniazd--pojęcie-sposób-realizacji-i-zastosowanie>Mechanizm gniazd – pojęcie, sposób realizacji i zastosowanie<a hidden class=anchor aria-hidden=true href=#mechanizm-gniazd--pojęcie-sposób-realizacji-i-zastosowanie>#</a></h1><h1 id=metody-obsługi-wielu-klientów-równolegle-w-aplikacjach-sieciowych>Metody obsługi wielu klientów równolegle w aplikacjach sieciowych.<a hidden class=anchor aria-hidden=true href=#metody-obsługi-wielu-klientów-równolegle-w-aplikacjach-sieciowych>#</a></h1><p>Zadania związane z obsługą ruchu w aplikacjach sieciowych zawsze mają duże opóźnienia związane z ciągłym czekaniem na odpowiedź. W zależności od wykorzystywanego języka można poradzić sobie z nimi na kilka sposobów.</p><ol><li>tworzenie zielonych wątków (wiele języków wprowadza własną definicję wątków) do obsługi zapytania</li><li>wykorzystanie mechanizmów asynchronicznych (np pętla zdarzeń w JS lub async scheduler w RUST)</li></ol><h1 id=pocztowe-protokoły-warstwy-aplikacji>Pocztowe protokoły warstwy aplikacji.<a hidden class=anchor aria-hidden=true href=#pocztowe-protokoły-warstwy-aplikacji>#</a></h1><p>SMPT, POP, IMAP</p><h1 id=porównanie-http-i-websocket>Porównanie HTTP i WebSocket.<a hidden class=anchor aria-hidden=true href=#porównanie-http-i-websocket>#</a></h1><p>HTTP służy do przesłania pakietu danych, websocket nawiązuje połącznie utrzymywane przez dłuższy okres czasu. Oba korzystają z TCP. WebSocket tworzy tunel i pozwala na przesyłanie wiadomości między dwoma komunikującymi się stronami, HTTP jest oparte o model ZAPYTANIE->ODPOWIEDŹ.</p><h1 id=atrybuty-bezpieczeństwa-informacji>Atrybuty bezpieczeństwa informacji.<a hidden class=anchor aria-hidden=true href=#atrybuty-bezpieczeństwa-informacji>#</a></h1><h1 id=modele-dystrybucji-kluczy-kryptograficznych>Modele dystrybucji kluczy kryptograficznych.<a hidden class=anchor aria-hidden=true href=#modele-dystrybucji-kluczy-kryptograficznych>#</a></h1><h1 id=rodzaje-zagrożeń-oraz-ochrona-aplikacji-sieciowych>Rodzaje zagrożeń oraz ochrona aplikacji sieciowych.<a hidden class=anchor aria-hidden=true href=#rodzaje-zagrożeń-oraz-ochrona-aplikacji-sieciowych>#</a></h1><h1 id=charakterystyka-kryptografii-symetrycznej-oraz-asymetrycznej>Charakterystyka kryptografii symetrycznej oraz asymetrycznej.<a hidden class=anchor aria-hidden=true href=#charakterystyka-kryptografii-symetrycznej-oraz-asymetrycznej>#</a></h1></div><footer class=post-footer><ul class=post-tags></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//nxyt.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2023 <a href=https://nxyt.pl/blog>just some developer thoughts</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>