<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Perfect programming language | just some developer thoughts</title><meta name=keywords content><meta name=description content="Hello, as someone that likes to try out new things I&rsquo;ve used plenty of programming languages, some popular, some niche and not widely known. This post sums up my experiences as wishlist of things I&rsquo;d like my perfect language to have. This list is obviously subjective and there are some things that I might like, but you don&rsquo;t - if that&rsquo;s the case feel free to write comment with things you disagree with."><meta name=author content><link rel=canonical href=https://nxyt.pl/blog/posts/perfect_programming_language/><link crossorigin=anonymous href=/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe+FVUFzPh7U=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://nxyt.pl/blog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://nxyt.pl/blog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://nxyt.pl/blog/favicon-32x32.png><link rel=apple-touch-icon href=https://nxyt.pl/blog/apple-touch-icon.png><link rel=mask-icon href=https://nxyt.pl/blog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script><meta property="og:title" content="Perfect programming language"><meta property="og:description" content="Hello, as someone that likes to try out new things I&rsquo;ve used plenty of programming languages, some popular, some niche and not widely known. This post sums up my experiences as wishlist of things I&rsquo;d like my perfect language to have. This list is obviously subjective and there are some things that I might like, but you don&rsquo;t - if that&rsquo;s the case feel free to write comment with things you disagree with."><meta property="og:type" content="article"><meta property="og:url" content="https://nxyt.pl/blog/posts/perfect_programming_language/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-12T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-12T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Perfect programming language"><meta name=twitter:description content="Hello, as someone that likes to try out new things I&rsquo;ve used plenty of programming languages, some popular, some niche and not widely known. This post sums up my experiences as wishlist of things I&rsquo;d like my perfect language to have. This list is obviously subjective and there are some things that I might like, but you don&rsquo;t - if that&rsquo;s the case feel free to write comment with things you disagree with."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"https://nxyt.pl/blog/posts/"},{"@type":"ListItem","position":3,"name":"Perfect programming language","item":"https://nxyt.pl/blog/posts/perfect_programming_language/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Perfect programming language","name":"Perfect programming language","description":"Hello, as someone that likes to try out new things I\u0026rsquo;ve used plenty of programming languages, some popular, some niche and not widely known. This post sums up my experiences as wishlist of things I\u0026rsquo;d like my perfect language to have. This list is obviously subjective and there are some things that I might like, but you don\u0026rsquo;t - if that\u0026rsquo;s the case feel free to write comment with things you disagree with.","keywords":[],"articleBody":"Hello, as someone that likes to try out new things I’ve used plenty of programming languages, some popular, some niche and not widely known. This post sums up my experiences as wishlist of things I’d like my perfect language to have. This list is obviously subjective and there are some things that I might like, but you don’t - if that’s the case feel free to write comment with things you disagree with. One last small disclaimer - I’ll be writing about my ‘perfect general purpose programming language’, there are some applications where I’d be happy to give up on many things from this list - shell languages come to mind as one example that doesn’t need many of features I’ll list and instead they should allow you to quickly and conveniently interact with system.\nStatic typing My first request is for the language to have static typing. Let’s be honest, dynamically typed languages don’t have many proponents these days for good reason. Being programmer is more about reading code, than writing it. Static typing allows you to quickly get a glimpse of part of the system to know what the arguments types are and what does the function output. Good evidence of superiority of typed languages is the fact that even dynamically typed languages have typed layer on top of them now (f.e. TypeScript or optional types in Python). Static typing gives more information about your program to compiler or interpreter, so it can make better decisions on how the code will be executing leading to potentially better performance and memory footprint. I personally don’t see almost any advantages of dynamic typing.\nSum types Sum types are great tool that I’m missing very much in Golang. If you don’t know what they are, it’s type that can be one of multiple other types. It’ll be probably easier to show example :P\ntype Event = Donation | Patron | Raid; This example comes straight from one of my codebases and showcases how sum types can help you model things using composition instead of inheritance. What we’re basically saying here is that type ‘Event’ can come in one of three shapes - ‘Donation’, ‘Patron’ or ‘Raid’. We could model that using inheritance instead (by creating class ‘Donation’ that would inherit ‘Event’ class), but first - composition is my preferred way of doing polymorphism and secondly - sometimes sum types are more versatile. Classes usually describe behavior, and sum types describe data. Now we can create array of Events, and it’s very easy to look up what shape can Event have.\nPattern matching Sum types are the best when they’re used with some other mechanism allowing to quickly assert type of variable. The best mechanism for that use case (and many more) is Rust pattern matching. Given the same example as before, here’s how we’d easily use sum types with pattern matching in Rust.\nenum Event { Donation, Raid, Patron, } fn DisplayEvent(event: Event) { match event { Event::Donation =\u003e println!(\"Donation\"), Event::Raid =\u003e println!(\"Raid\"), Event::Patron =\u003e { // do something special println!(\"Patron\") }, } } Rust pattern matching is exhaustive meaning that you need to serve all possible branches which is great for predictability of your programs. It also has many other great features such as catch all and can actually match very nested types.\nenum Event { Donation(Donation), Raid, Patron, } enum DonationType { Fiat(f64), Crypto(f64), } ... match event { Event::Donation(DonationType::Crypto(amount)) =\u003e { // in this example Donation is actually another Sum type and in this branch we can directly access // amount of cryptocurrency donation and get less nested matches/if statements println!(\"{}\", amount) }, _ =\u003e { // catch all branch // if 'event' variable doesn't match any other branch then this will be executed // you can think of this as 'else' in 'if statement' }, } You get my point. Rust actually has more functionality related to pattern matching (like matching on ranges), but even simple naive exhaustive pattern matching would be greatly appreciated in any language I use.\nError as values Returning errors as values is great practice in my opinion and allows you to easily locate places where your program can fail. It makes your code more verbose, but verbose is better than unpredictable if you ask me :P Here’s how Golang uses multiple returns as a way to do error handling\nfunc CanFail() (string, error) { return \"\", fmt.Errorf(\"This function failed\") } func UsesCanFail() { str, err := CanFail() if err != nil { fmt.Println(\"This function failed: \", err) } else { fmt.Println(str) } } It’s very nice that you can look at function signature and can immediately tell if function can fail. Furthermore, it also leads to much more robust code, as it forces you to handle all failure cases. There are things you might not like about Go, but returning errors as values should not be one of them.\nOptions/Results types and some syntax around them Using multiple returns is just one way of returning errors as values and not necessarily the best one. Don’t quote me on that, but I think the language that first popularized concept of Optionals and Results was Haskell (again - don’t quote me on that :P). Those are very nice use case of sum types to model operations that can return something/nothing or that can fail along the way. My favorite language with Options/Results is Rust so let’s see how it uses them.\nasync fn get_active_stream(\u0026self) -\u003e Result\u003cOption\u003cLiveBroadcast\u003e\u003e { let mut broadcasts = self.list_active_broacasts().await?.into_iter().filter(|f| { f.status .as_ref() .is_some_and(|f| f.life_cycle_status.as_ref().is_some_and(|s| s == \"live\")) }); let active = broadcasts.next(); Ok(active) } To me Options and Result are such a clean way of expressing outcomes of operations. You only need to read the first line to know that function get_active_stream can fail and if it succeeds it returns some stream or nothing (if there isn’t any stream ongoing). Pattern matching on every operation would be very exhausting though, so Rust has ? operator, that allows us to return Result if it’s Error. In the first line you can see self.list_active_broacasts().await? which basically means “if list_active_broadcasts returned Result containing Error, then return whole function with that error. If it has some value unwrap it and go forward”. This way we can chain Options/Results without much hassle and still get all the benefits of them. Perfect :-)\nFunctions as first class objects We want functions to be treated as first class objects. This allows for many interesting patterns such as passing function to another function. Great example of using such feature is Map function that accepts another function to change some set of elements to another set of elements. This kind of dependency injection can allow very flexible programs, that are easier to maintain.\nCompiled and not interpreted Most languages have no reason to be interpreted languages. We write some code and then ship interpreter with few files that are executed over and over again. What’s the point of interpreter if it always runs the same code? Why use interpreted language if you then have to ship interpreter with the code it will be running? If you ask me it’s one of the worst parts of JS legacy. People were familiar with JS, so NodeJS was created, and now we have to ship NodeJS in every docker container. This whole thing is even worse now, as we’re using Typescript, so we’re compiling our code into other code that in the end is not compiled into binary and will be ran by interpreter instead. If you ask me, there’s only one good place for interpreter - shell. Golang proved that compiled languages can compile SUPER FAST, seriously! Even bigger Golang projects compile so fast, that compilation+execution will be at least as fast as running similar code on interpreter. To reiterate - interpreted languages are okay.. for shells and browsers. Most other code should be compiled unless you have really good reason for it not to be.\nImplicit memory allocations (automatic memory management) I’ll tell you a secret - most of us are kind of dummies. It’s easy to make mistakes with manual memory management and what’s more important manual memory management takes your attention away from business logic. I’d like to avoid GC, but if that’s the price for convenience - I’ll take it! JS proved that most people don’t care about memory footprint or performance of their programs, so we don’t have to be purists and fight GC at all cost. Beside - there are examples of great GC languages like Go which is very lightweight and will make your programs fast and light without requiring you to allocate memory manually. One other approach I really like is Rust memory management. It doesn’t use GC, but it’s strict borrowing rules allows compiler to deduce when the memory for each variable should be allocated and freed. It comes with a price though - writing reference lifetimes is no fun at all, and I’d happily turn on Rust GC mode if it allowed me to skip annotating them. I’ve heard that Ocaml allows the opposite - it uses GC, but will allow you to annotate lifetimes for the times you need the performance. That seems to be the best of the both worlds to me, but I haven’t used Ocaml much yet.\nNo cost abstractions I mean, why would I want my abstractions to have cost. The ability to use functions like for_each()/map() without any additional cost (as they are compiled into simple for loops) is great thing to have in any language.\nSome sort of clean compile time execution Having a way to run some code during compilation can sometimes be very convenient and the best implementation of this concept I’ve seen is Zig with it’s comptime. If you ever see this keyword it means that the code will be run during compilation, and it’ll have no runtime cost.\npub fn main() void { const len = comptime add(1, 3); const len_2 = comptime some_heavy_calculation(); const arr: [len]u8 = undefined; const another_arr: [len_2]u8 = undefined; } If you run this program comptime add(1,3) will be swapped for raw value 4, the same will happen with len_2. It can be really handy to calculate some values during compilation instead of calculating them on each program execution.\nPackage manager I’m not even considering a language that doesn’t have package manager. Call me lazy, but to me, it’s essential feature of any new language. Code reusing is such a bit part of our work that some package manager endorsed by language creators (to avoid splitting the ecosystem) is a must. Maybe some people prefer cloning git repositories into their projects, but that’s not me.\nLSP One of the most important tools while writing code has to be good LSP that will catch all the errors and will give you hints regarding your code. I’d certainly consider it essential part of any language ecosystem.\nEnding notes This list can change in the future (if I encounter new features that I really like), but right now these are all the features I’d really love to have in one language. There isn’t any such language right now, but I think 2 that come really close are Rust and Golang. My perfect language probably sits somewhere in between which is not surprising considering the fact that they’re both really well-thought-out and are gaining popularity as a result of that.\n","wordCount":"1900","inLanguage":"en","datePublished":"2023-12-12T00:00:00Z","dateModified":"2023-12-12T00:00:00Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://nxyt.pl/blog/posts/perfect_programming_language/"},"publisher":{"@type":"Organization","name":"just some developer thoughts","logo":{"@type":"ImageObject","url":"https://nxyt.pl/blog/favicon.ico"}}}</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-D4BXHY930J",{anonymize_ip:!1})}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://nxyt.pl/blog accesskey=h title="just some developer thoughts (Alt + H)">just some developer thoughts</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Perfect programming language</h1><div class=post-meta><span title='2023-12-12 00:00:00 +0000 UTC'>December 12, 2023</span></div></header><div class=post-content><p>Hello, as someone that likes to try out new things I&rsquo;ve used plenty of programming languages, some popular, some niche and not widely known.
This post sums up my experiences as wishlist of things I&rsquo;d like my perfect language to have. This list is obviously subjective and there are some things that I might like, but you don&rsquo;t - if that&rsquo;s the case feel free to write comment with things you disagree with.
One last small disclaimer - I&rsquo;ll be writing about my &lsquo;perfect general purpose programming language&rsquo;, there are some applications where I&rsquo;d be happy to give up on many things from this list - shell languages come to mind as one example that doesn&rsquo;t need many of features I&rsquo;ll list and instead they should allow you to quickly and conveniently interact with system.</p><h1 id=static-typing>Static typing<a hidden class=anchor aria-hidden=true href=#static-typing>#</a></h1><p>My first request is for the language to have static typing. Let&rsquo;s be honest, dynamically typed languages don&rsquo;t have many proponents these days for good reason. Being programmer is more about reading code, than writing it. Static typing allows you to quickly get a glimpse of part of the system to know what the arguments types are and what does the function output.
Good evidence of superiority of typed languages is the fact that even dynamically typed languages have typed layer on top of them now (f.e. TypeScript or optional types in Python).
Static typing gives more information about your program to compiler or interpreter, so it can make better decisions on how the code will be executing leading to potentially better performance and memory footprint. I personally don&rsquo;t see almost any advantages of dynamic typing.</p><h1 id=sum-types>Sum types<a hidden class=anchor aria-hidden=true href=#sum-types>#</a></h1><p>Sum types are great tool that I&rsquo;m missing very much in Golang. If you don&rsquo;t know what they are, it&rsquo;s type that can be one of multiple other types. It&rsquo;ll be probably easier to show example :P</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Event</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Donation</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Patron</span> <span style=color:#f92672>|</span> <span style=color:#a6e22e>Raid</span>;
</span></span></code></pre></div><p>This example comes straight from one of my codebases and showcases how sum types can help you model things using composition instead of inheritance. What we&rsquo;re basically saying here is that type &lsquo;Event&rsquo; can come in one of three shapes - &lsquo;Donation&rsquo;, &lsquo;Patron&rsquo; or &lsquo;Raid&rsquo;. We could model that using inheritance instead (by creating class &lsquo;Donation&rsquo; that would inherit &lsquo;Event&rsquo; class), but first - composition is my preferred way of doing polymorphism and secondly - sometimes sum types are more versatile. Classes usually describe behavior, and sum types describe data. Now we can create array of Events, and it&rsquo;s very easy to look up what shape can Event have.</p><h1 id=pattern-matching>Pattern matching<a hidden class=anchor aria-hidden=true href=#pattern-matching>#</a></h1><p>Sum types are the best when they&rsquo;re used with some other mechanism allowing to quickly assert type of variable. The best mechanism for that use case (and many more) is Rust pattern matching. Given the same example as before, here&rsquo;s how we&rsquo;d easily use sum types with pattern matching in Rust.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Event</span> {
</span></span><span style=display:flex><span>    Donation,
</span></span><span style=display:flex><span>    Raid,
</span></span><span style=display:flex><span>    Patron,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>DisplayEvent</span>(event: <span style=color:#a6e22e>Event</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>match</span> event {
</span></span><span style=display:flex><span>        Event::Donation <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Donation&#34;</span>),
</span></span><span style=display:flex><span>        Event::Raid <span style=color:#f92672>=&gt;</span> println!(<span style=color:#e6db74>&#34;Raid&#34;</span>),
</span></span><span style=display:flex><span>        Event::Patron <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// do something special
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            println!(<span style=color:#e6db74>&#34;Patron&#34;</span>)
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>} 
</span></span></code></pre></div><p>Rust pattern matching is exhaustive meaning that you need to serve all possible branches which is great for predictability of your programs. It also has many other great features such as catch all and can actually match very nested types.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>Event</span> {
</span></span><span style=display:flex><span>    Donation(Donation),
</span></span><span style=display:flex><span>    Raid,
</span></span><span style=display:flex><span>    Patron,
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#66d9ef>enum</span> <span style=color:#a6e22e>DonationType</span> {
</span></span><span style=display:flex><span>  Fiat(<span style=color:#66d9ef>f64</span>),
</span></span><span style=display:flex><span>  Crypto(<span style=color:#66d9ef>f64</span>),
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#f92672>..</span>.
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>match</span> event {
</span></span><span style=display:flex><span>      Event::Donation(DonationType::Crypto(amount)) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// in this example Donation is actually another Sum type and in this branch we can directly access
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// amount of cryptocurrency donation and get less nested matches/if statements
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        println!(<span style=color:#e6db74>&#34;{}&#34;</span>, amount)
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>      _ <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>          <span style=color:#75715e>// catch all branch
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#75715e>// if &#39;event&#39; variable doesn&#39;t match any other branch then this will be executed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          <span style=color:#75715e>// you can think of this as &#39;else&#39; in &#39;if statement&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      },
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><p>You get my point. Rust actually has more functionality related to pattern matching (like matching on ranges), but even simple naive exhaustive pattern matching would be greatly appreciated in any language I use.</p><h1 id=error-as-values>Error as values<a hidden class=anchor aria-hidden=true href=#error-as-values>#</a></h1><p>Returning errors as values is great practice in my opinion and allows you to easily locate places where your program can fail. It makes your code more verbose, but verbose is better than unpredictable if you ask me :P
Here&rsquo;s how Golang uses multiple returns as a way to do error handling</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>CanFail</span>() (<span style=color:#66d9ef>string</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;&#34;</span>, <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Errorf</span>(<span style=color:#e6db74>&#34;This function failed&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>UsesCanFail</span>() {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>str</span>, <span style=color:#a6e22e>err</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>CanFail</span>()
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>err</span> <span style=color:#f92672>!=</span> <span style=color:#66d9ef>nil</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#e6db74>&#34;This function failed: &#34;</span>, <span style=color:#a6e22e>err</span>)
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(<span style=color:#a6e22e>str</span>)
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It&rsquo;s very nice that you can look at function signature and can immediately tell if function can fail. Furthermore, it also leads to much more robust code, as it forces you to handle all failure cases. There are things you might not like about Go, but returning errors as values should not be one of them.</p><h1 id=optionsresults-types-and-some-syntax-around-them>Options/Results types and some syntax around them<a hidden class=anchor aria-hidden=true href=#optionsresults-types-and-some-syntax-around-them>#</a></h1><p>Using multiple returns is just one way of returning errors as values and not necessarily the best one. Don&rsquo;t quote me on that, but I think the language that first popularized concept of Optionals and Results was Haskell (again - don&rsquo;t quote me on that :P). Those are very nice use case of sum types to model operations that can return something/nothing or that can fail along the way. My favorite language with Options/Results is Rust so let&rsquo;s see how it uses them.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>async</span> <span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>get_active_stream</span>(<span style=color:#f92672>&amp;</span>self) -&gt; Result<span style=color:#f92672>&lt;</span>Option<span style=color:#f92672>&lt;</span>LiveBroadcast<span style=color:#f92672>&gt;&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#66d9ef>mut</span> broadcasts <span style=color:#f92672>=</span> self.list_active_broacasts().<span style=color:#66d9ef>await</span><span style=color:#f92672>?</span>.into_iter().filter(<span style=color:#f92672>|</span>f<span style=color:#f92672>|</span> {
</span></span><span style=display:flex><span>        f.status
</span></span><span style=display:flex><span>            .as_ref()
</span></span><span style=display:flex><span>            .is_some_and(<span style=color:#f92672>|</span>f<span style=color:#f92672>|</span> f.life_cycle_status.as_ref().is_some_and(<span style=color:#f92672>|</span>s<span style=color:#f92672>|</span> s <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;live&#34;</span>))
</span></span><span style=display:flex><span>    });
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> active <span style=color:#f92672>=</span> broadcasts.next();
</span></span><span style=display:flex><span>    Ok(active)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To me Options and Result are such a clean way of expressing outcomes of operations. You only need to read the first line to know that function get_active_stream can fail and if it succeeds it returns some stream or nothing (if there isn&rsquo;t any stream ongoing). Pattern matching on every operation would be very exhausting though, so Rust has ? operator, that allows us to return Result if it&rsquo;s Error. In the first line you can see <code>self.list_active_broacasts().await?</code> which basically means &ldquo;if list_active_broadcasts returned Result containing Error, then return whole function with that error. If it has some value unwrap it and go forward&rdquo;. This way we can chain Options/Results without much hassle and still get all the benefits of them. Perfect :-)</p><h1 id=functions-as-first-class-objects>Functions as first class objects<a hidden class=anchor aria-hidden=true href=#functions-as-first-class-objects>#</a></h1><p>We want functions to be treated as first class objects. This allows for many interesting patterns such as passing function to another function. Great example of using such feature is Map function that accepts another function to change some set of elements to another set of elements. This kind of dependency injection can allow very flexible programs, that are easier to maintain.</p><h1 id=compiled-and-not-interpreted>Compiled and not interpreted<a hidden class=anchor aria-hidden=true href=#compiled-and-not-interpreted>#</a></h1><p>Most languages have no reason to be interpreted languages. We write some code and then ship interpreter with few files that are executed over and over again. What&rsquo;s the point of interpreter if it always runs the same code? Why use interpreted language if you then have to ship interpreter with the code it will be running? If you ask me it&rsquo;s one of the worst parts of JS legacy. People were familiar with JS, so NodeJS was created, and now we have to ship NodeJS in every docker container. This whole thing is even worse now, as we&rsquo;re using Typescript, so we&rsquo;re compiling our code into other code that in the end is not compiled into binary and will be ran by interpreter instead. If you ask me, there&rsquo;s only one good place for interpreter - shell. Golang proved that compiled languages can compile SUPER FAST, seriously! Even bigger Golang projects compile so fast, that compilation+execution will be at least as fast as running similar code on interpreter.
To reiterate - interpreted languages are okay.. for shells and browsers. Most other code should be compiled unless you have really good reason for it not to be.</p><h1 id=implicit-memory-allocations-automatic-memory-management>Implicit memory allocations (automatic memory management)<a hidden class=anchor aria-hidden=true href=#implicit-memory-allocations-automatic-memory-management>#</a></h1><p>I&rsquo;ll tell you a secret - most of us are kind of dummies. It&rsquo;s easy to make mistakes with manual memory management and what&rsquo;s more important manual memory management takes your attention away from business logic. I&rsquo;d like to avoid GC, but if that&rsquo;s the price for convenience - I&rsquo;ll take it! JS proved that most people don&rsquo;t care about memory footprint or performance of their programs, so we don&rsquo;t have to be purists and fight GC at all cost. Beside - there are examples of great GC languages like Go which is very lightweight and will make your programs fast and light without requiring you to allocate memory manually.
One other approach I really like is Rust memory management. It doesn&rsquo;t use GC, but it&rsquo;s strict borrowing rules allows compiler to deduce when the memory for each variable should be allocated and freed. It comes with a price though - writing reference lifetimes is no fun at all, and I&rsquo;d happily turn on Rust GC mode if it allowed me to skip annotating them. I&rsquo;ve heard that Ocaml allows the opposite - it uses GC, but will allow you to annotate lifetimes for the times you need the performance. That seems to be the best of the both worlds to me, but I haven&rsquo;t used Ocaml much yet.</p><h1 id=no-cost-abstractions>No cost abstractions<a hidden class=anchor aria-hidden=true href=#no-cost-abstractions>#</a></h1><p>I mean, why would I want my abstractions to have cost. The ability to use functions like for_each()/map() without any additional cost (as they are compiled into simple for loops) is great thing to have in any language.</p><h1 id=some-sort-of-clean-compile-time-execution>Some sort of clean compile time execution<a hidden class=anchor aria-hidden=true href=#some-sort-of-clean-compile-time-execution>#</a></h1><p>Having a way to run some code during compilation can sometimes be very convenient and the best implementation of this concept I&rsquo;ve seen is Zig with it&rsquo;s comptime. If you ever see this keyword it means that the code will be run during compilation, and it&rsquo;ll have no runtime cost.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-zig data-lang=zig><span style=display:flex><span><span style=color:#66d9ef>pub</span> <span style=color:#66d9ef>fn</span> main() <span style=color:#66d9ef>void</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> len <span style=color:#f92672>=</span> <span style=color:#66d9ef>comptime</span> add(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> len_2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>comptime</span> some_heavy_calculation();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> arr<span style=color:#f92672>:</span> [len]<span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> another_arr<span style=color:#f92672>:</span> [len_2]<span style=color:#66d9ef>u8</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>undefined</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>If you run this program <code>comptime add(1,3)</code> will be swapped for raw value <code>4</code>, the same will happen with <code>len_2</code>. It can be really handy to calculate some values during compilation instead of calculating them on each program execution.</p><h1 id=package-manager>Package manager<a hidden class=anchor aria-hidden=true href=#package-manager>#</a></h1><p>I&rsquo;m not even considering a language that doesn&rsquo;t have package manager. Call me lazy, but to me, it&rsquo;s essential feature of any new language. Code reusing is such a bit part of our work that some package manager endorsed by language creators (to avoid splitting the ecosystem) is a must. Maybe some people prefer cloning git repositories into their projects, but that&rsquo;s not me.</p><h1 id=lsp>LSP<a hidden class=anchor aria-hidden=true href=#lsp>#</a></h1><p>One of the most important tools while writing code has to be good LSP that will catch all the errors and will give you hints regarding your code. I&rsquo;d certainly consider it essential part of any language ecosystem.</p><h3 id=ending-notes>Ending notes<a hidden class=anchor aria-hidden=true href=#ending-notes>#</a></h3><p>This list can change in the future (if I encounter new features that I really like), but right now these are all the features I&rsquo;d really love to have in one language. There isn&rsquo;t any such language right now, but I think 2 that come really close are Rust and Golang. My perfect language probably sits somewhere in between which is not surprising considering the fact that they&rsquo;re both really well-thought-out and are gaining popularity as a result of that.</p></div><footer class=post-footer><ul class=post-tags></ul></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//nxyt.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2024 <a href=https://nxyt.pl/blog>just some developer thoughts</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>