<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>rust on just some developer thoughts</title><link>https://nxyt.pl/blog/tags/rust/</link><description>Recent content in rust on just some developer thoughts</description><generator>Hugo -- gohugo.io</generator><language>pl-PL</language><lastBuildDate>Fri, 08 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://nxyt.pl/blog/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>Rust Std Mutex vs Tokio Mutex</title><link>https://nxyt.pl/blog/posts/rust_std_tokio_mutex/</link><pubDate>Fri, 08 Mar 2024 00:00:00 +0000</pubDate><guid>https://nxyt.pl/blog/posts/rust_std_tokio_mutex/</guid><description>My last post was about benchmarking mutexes and actor model. I was wondering what&amp;rsquo;s a faster way to synchronize state and conclusion of my findings was that mutexes are 2-3 times faster depending on the exact Actor implementation. There was one underlying assumption that I didn&amp;rsquo;t specify explicitly in those benchmarks - I was using Tokio implementation of mutexes. Tokio mutexes are slower than their Std counterpart, so why would anyone pick them.</description></item><item><title>Rust - Mutex vs Actor benchmark</title><link>https://nxyt.pl/blog/posts/mutex_actor_benchmark/</link><pubDate>Tue, 30 Jan 2024 00:00:00 +0000</pubDate><guid>https://nxyt.pl/blog/posts/mutex_actor_benchmark/</guid><description>Hello, this post is quick summary of my findings when I was benchmarking Actor model vs Mutex for concurrent access to value in async environment. All code for this benchmark is available in my github repo, but I&amp;rsquo;ve decided to copy some parts of implementation here.
Actor implementation #[derive(Default)] pub struct BenchActor { count: i64, /// optional channel to signal when implementation reached REACHED_COUNT_SIGNAL_AMOUNT tx: Option&amp;lt;oneshot::Sender&amp;lt;()&amp;gt;&amp;gt;, } pub enum Message { IncreaseBySync(i64, oneshot::Sender&amp;lt;()&amp;gt;), DecreaseBySync(i64, oneshot::Sender&amp;lt;()&amp;gt;), IncreaseBy(i64), DecreaseBy(i64), Get(oneshot::Sender&amp;lt;i64&amp;gt;), } impl BenchActor { pub fn new(m: oneshot::Sender&amp;lt;()&amp;gt;) -&amp;gt; Self { Self { tx: Some(m), .</description></item><item><title>Golang vs Rust</title><link>https://nxyt.pl/blog/posts/go_vs_rust/</link><pubDate>Wed, 20 Dec 2023 00:00:00 +0000</pubDate><guid>https://nxyt.pl/blog/posts/go_vs_rust/</guid><description>Yes, it&amp;rsquo;s another one of those ðŸ˜ˆ My programming journey started few years ago with typescript (unsurprisingly), but sooner rather than later I&amp;rsquo;ve developed a view that typescript doesn&amp;rsquo;t have any advantages on the backend. Seriously, does typescript have any advantages over alternatives in this space? It&amp;rsquo;s interpreted, so we need to package runtime with our code to get it to work, even if it doesn&amp;rsquo;t have benefits of compiled languages we need compile step, it doesn&amp;rsquo;t have good native tooling (you need 3rd party projects for things like formatting), it&amp;rsquo;s not very safe language (f.</description></item><item><title>How I've reduced CI rust tests duration 4x with caching and Nix!</title><link>https://nxyt.pl/blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/</link><pubDate>Thu, 20 Apr 2023 09:03:20 -0800</pubDate><guid>https://nxyt.pl/blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/</guid><description>One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we&amp;rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15 minutes. This post was made to help people struggling with similar issues.
Project Structure The way I structure my projects will influence some of the further solutions, so I thought it&amp;rsquo;s worthwhile sharing</description></item></channel></rss>