<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>nix on just some developer thoughts</title><link>https://nxyt.pl/blog/tags/nix/</link><description>Recent content in nix on just some developer thoughts</description><generator>Hugo -- gohugo.io</generator><language>pl-PL</language><lastBuildDate>Thu, 20 Apr 2023 09:03:20 -0800</lastBuildDate><atom:link href="https://nxyt.pl/blog/tags/nix/index.xml" rel="self" type="application/rss+xml"/><item><title>How I've reduced CI rust tests duration 4x with caching and Nix!</title><link>https://nxyt.pl/blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/</link><pubDate>Thu, 20 Apr 2023 09:03:20 -0800</pubDate><guid>https://nxyt.pl/blog/posts/how-i-reduced-ci-rust-tests-duration-35-times-with-caching-and-nix/</guid><description>One of my project consists of backend (rust) split into many services and frontend made with Svelte. Sooner rather than later I found out that rust builds that we&amp;rsquo;re rather quick locally took ages in CI, resulting in poor CI feedback experience and test times exceeding 15 minutes. This post was made to help people struggling with similar issues.
Project Structure The way I structure my projects will influence some of the further solutions, so I thought it&amp;rsquo;s worthwhile sharing</description></item><item><title>How to use Nix to make reproducible dev environments</title><link>https://nxyt.pl/blog/posts/using-nix-for-dev-environment/</link><pubDate>Fri, 17 Mar 2023 09:03:20 -0800</pubDate><guid>https://nxyt.pl/blog/posts/using-nix-for-dev-environment/</guid><description>Perhaps just like me, you see value in making easily reproducible dev environments. Wouldn&amp;rsquo;t it be great if you could have projects with different versions of dependencies that anyone could just jump right into, type command or two and have everything necessary for contributing?
Well, I think it&amp;rsquo;s something that everyone should take into consideration. Reproducible dev environments have one more pro - there are self-documenting state of your project. You can look into things your dev env provides you to know which programming languages and tools the project is using.</description></item></channel></rss>