<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Why You should be using Nix instead of Dockerfiles | just some developer thoughts</title>
<meta name="keywords" content="">
<meta name="description" content="Lately I&rsquo;ve had to move building and pushing docker images process to CI. To my surprise it wasn&rsquo;t as straightforward as it should be. Building images on GitHub CI runner worked just fine, but my image registry had no SSL and adding &lsquo;insecure&rsquo; registry to docker can be a pain. Sure - I could write script that changes docker daemon.json configuration and restarts it, but it felt like a hack. I&rsquo;ve also tried using podman and buildah, but both of them didn&rsquo;t seem to get the job done in easy manner.">
<meta name="author" content="">
<link rel="canonical" href="https://nxyt.pl/blog/posts/why_nix_instead_of_docker/">
<link crossorigin="anonymous" href="/blog/assets/css/stylesheet.3613efbd0b1772781e8f49935e973cae632a7f61471c05b17be155505ccf87b5.css" integrity="sha256-NhPvvQsXcngej0mTXpc8rmMqf2FHHAWxe&#43;FVUFzPh7U=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/blog/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://nxyt.pl/blog/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://nxyt.pl/blog/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://nxyt.pl/blog/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://nxyt.pl/blog/apple-touch-icon.png">
<link rel="mask-icon" href="https://nxyt.pl/blog/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-D4BXHY930J', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Why You should be using Nix instead of Dockerfiles" />
<meta property="og:description" content="Lately I&rsquo;ve had to move building and pushing docker images process to CI. To my surprise it wasn&rsquo;t as straightforward as it should be. Building images on GitHub CI runner worked just fine, but my image registry had no SSL and adding &lsquo;insecure&rsquo; registry to docker can be a pain. Sure - I could write script that changes docker daemon.json configuration and restarts it, but it felt like a hack. I&rsquo;ve also tried using podman and buildah, but both of them didn&rsquo;t seem to get the job done in easy manner." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://nxyt.pl/blog/posts/why_nix_instead_of_docker/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-26T13:03:20-08:00" />
<meta property="article:modified_time" content="2023-10-26T13:03:20-08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Why You should be using Nix instead of Dockerfiles"/>
<meta name="twitter:description" content="Lately I&rsquo;ve had to move building and pushing docker images process to CI. To my surprise it wasn&rsquo;t as straightforward as it should be. Building images on GitHub CI runner worked just fine, but my image registry had no SSL and adding &lsquo;insecure&rsquo; registry to docker can be a pain. Sure - I could write script that changes docker daemon.json configuration and restarts it, but it felt like a hack. I&rsquo;ve also tried using podman and buildah, but both of them didn&rsquo;t seem to get the job done in easy manner."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://nxyt.pl/blog/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Why You should be using Nix instead of Dockerfiles",
      "item": "https://nxyt.pl/blog/posts/why_nix_instead_of_docker/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Why You should be using Nix instead of Dockerfiles",
  "name": "Why You should be using Nix instead of Dockerfiles",
  "description": "Lately I\u0026rsquo;ve had to move building and pushing docker images process to CI. To my surprise it wasn\u0026rsquo;t as straightforward as it should be. Building images on GitHub CI runner worked just fine, but my image registry had no SSL and adding \u0026lsquo;insecure\u0026rsquo; registry to docker can be a pain. Sure - I could write script that changes docker daemon.json configuration and restarts it, but it felt like a hack. I\u0026rsquo;ve also tried using podman and buildah, but both of them didn\u0026rsquo;t seem to get the job done in easy manner.",
  "keywords": [
    
  ],
  "articleBody": "Lately I’ve had to move building and pushing docker images process to CI. To my surprise it wasn’t as straightforward as it should be. Building images on GitHub CI runner worked just fine, but my image registry had no SSL and adding ‘insecure’ registry to docker can be a pain. Sure - I could write script that changes docker daemon.json configuration and restarts it, but it felt like a hack. I’ve also tried using podman and buildah, but both of them didn’t seem to get the job done in easy manner.\nThat’s when I’ve decided to give Nix a try. I’m using Nix everywhere at this point - it handles my PC configuration, it handles my project dependencies, and I’m sure it will be able to build my images!\nIn hindsight the easiest way to do it would be using Skopeo (which I’ve actually ended up using in my nix solution) to push images built by docker, but issues mentioned above gave me a push to explore other possibilities and let me tell you - I don’t regret it.\nWhy would I use Nix instead of Docker?! Same dev and prod dependency versions Nix is ecosystem that greatly benefits from You using it in many places. If You’re using Nix to manage project dependencies, then chances are that some of them will be required in final docker image. With Nix you can be sure that dependencies You’re using locally are the same dependencies that will be contained within your final docker image.\nSmaller images With Nix it’s also really easy to make sure You don’t end up putting too much junk inside your images. That’s the advantage of declarative configuration - we specify what is needed and nix takes care of it for us. This way imperative commands like apt update will not accidentally pollute our containers. It’s not a guarantee however and depends on the ‘quality’ of packages you decide to include. Some packages may still include things that are not necessary, but it’s much easier to track them down - just look into .nix source of pkgs you import.\nReuse container image creation logic Nix also makes reusing code for multiple docker images much easier. Let me show you one example. One of the projects I’m developing is made using rust. It produces few binaries each from separate workspace member. My build phase looks like this buildPhase = \"cargo build --release --bin ${name}, so the only variable in whole Dockerfile would be binary name. To reuse logic responsible for building those images I’ve made separate buildPackage.nix file:\n{ pkgs ? import { }, path ? ./. }: let cargoFile = (builtins.fromTOML (builtins.readFile \"${path}/Cargo.toml\")); name = cargoFile.package.name; version = cargoFile.package.version; buildRustPackage = (pkgs.makeRustPlatform { cargo = pkgs.cargo; rustc = pkgs.rustc; }).buildRustPackage; dockerTools = pkgs.dockerTools; in rec { app = buildRustPackage { pname = name; version = version; src = ./.; buildAndTestSubdir = name; nativeBuildInputs = with pkgs; [ pkg-config ]; buildInputs = with pkgs; [ openssl ]; PKG_CONFIG_PATH = \"${pkgs.openssl.dev}/lib/pkgconfig\"; buildPhase = \"cargo build --release --bin ${name}\"; installPhase = '' mkdir -p $out/bin cp target/release/${name} $out/bin/ ''; cargoLock = { lockFile = ./Cargo.lock; }; }; buildImage = dockerTools.buildImage { name = name; tag = \"latest\"; copyToRoot = pkgs.buildEnv { name = \"image-root\"; paths = [ app pkgs.busybox pkgs.libtree ]; pathsToLink = [ \"/bin\" ]; }; config.Entrypoint = [ \"/bin/${name}\" ]; config.Env = [ \"SSL_CERT_FILE=${pkgs.cacert}/etc/ssl/certs/ca-bundle.crt\" ]; }; } It’s just a nix function! Now in my backend/default.nix I can easily build several rust binaries using the same ‘dockerfile’.\nlet buildPackage = import ./buildPackage.nix; in { serviceA = buildPackage { inherit pkgs; path = ./serviceA; }; serviceB = buildPackage { inherit pkgs; path = ./serviceB; }; } Build and push images with one command I admit, anything can be done in one command with shell scripts, but Nix gives us much stronger guarantees about correctness of our logic and I personally feel much more confident about using Nix instead of equivalent shell scripts. Anyway I’ve shown how I build my rust images in previous step, now let’s make Nix push the image for us.\n# reusable 'push' function that accepts docker image, name and optional tag pushImage = { imageTar, name, tag ? \"latest\" }: pkgs.writeShellScriptBin \"push-script\" '' ${pkgs.skopeo}/bin/skopeo copy docker-archive:${imageTar} docker://${yourImageRegistry}/${projectName}/${name}:${tag} --dest-tls-verify=false ''; # in output of flake packages = { serviceA = pushImage { imageTar = serviceA.buildImage; name = \"serviceA\"; }; serviceB = pushImage { imageTar = serviceB.buildImage; name = \"serviceB\"; }; }; Now to build and push image we run nix run .#serviceA. As You can probably tell I’m actually using skopeo to push the final image and IMAO one liner visible in pushImage function is great example of why Nix is so great. If I’d want to make shell script with equivalent functionality it would be necessary to make script that validates arguments given to it from CLI, then you’d need to make sure skopeo is installed (or worse - install it imperatively) and only then You’d be able to copy the image. Using Nix for this task it’s trivial. There’s no need to think about any of those things. You can just run anything packaged for Nix as if it was already installed.\nNix is the best abstraction for building environments Think about your docker container. What’s it purpose? It isolates network and runtime dependencies from your system. That’s what allows you to select which version of postgres you want to run easily. Even if they are used to making reproducible environments, it’s not the best tool for the job - f.e. they lack version locking mechanism. It can be used for this task, because as I mentioned it isolates runtime dependencies, but it’s side effect and not something baked into containers design. When we ship software we really need both - reproducible environment that can satisfy our runtime needs and runtime isolated from the underlying system. Nix + Docker combination gives us both, which is why I think using Nix to build images is great idea.\nWhat next Chances are You liked this short showcase of Nix, but still don’t know how to use it Yourself. Nix learning curve is pretty hard after all. If you want to build images using Nix, but aren’t very proficient in using the language I suggest the following learning path. First - package your software using Nix. In many cases it’ll boil down to using appropriate builder (like buildRustPackage in examples above, but there are similar functions for other languages as well), but sometimes it can be much harder, especially if Your project depends on software not available in nixpkgs. When your app is packaged correctly look into dockerTools.buildImage documentation. It’s rather simple to use, but if You have any questions about it feel free to ask in the comments. I sincerely think that the best way to learn nix is by actively using it. No amount of reading helps as much as just porting some Dockerfiles to flake.nix files, so experiment and have fun :-)\n",
  "wordCount" : "1168",
  "inLanguage": "en",
  "datePublished": "2023-10-26T13:03:20-08:00",
  "dateModified": "2023-10-26T13:03:20-08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://nxyt.pl/blog/posts/why_nix_instead_of_docker/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "just some developer thoughts",
    "logo": {
      "@type": "ImageObject",
      "url": "https://nxyt.pl/blog/favicon.ico"
    }
  }
}
</script>
    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-D4BXHY930J"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-D4BXHY930J', { 'anonymize_ip': false });
}
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://nxyt.pl/blog" accesskey="h" title="just some developer thoughts (Alt + H)">just some developer thoughts</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Why You should be using Nix instead of Dockerfiles
    </h1>
    <div class="post-meta"><span title='2023-10-26 13:03:20 -0800 -0800'>October 26, 2023</span>

</div>
  </header> 
  <div class="post-content"><p>Lately I&rsquo;ve had to move building and pushing docker images process to CI. To my surprise it wasn&rsquo;t as straightforward as it should be.
Building images on GitHub CI runner worked just fine, but my image registry had no SSL and adding &lsquo;insecure&rsquo; registry to docker can be a pain.
Sure - I could write script that changes docker <code>daemon.json</code> configuration and restarts it, but it felt like a hack. I&rsquo;ve also tried using
podman and buildah, but both of them didn&rsquo;t seem to get the job done in easy manner.</p>
<p>That&rsquo;s when I&rsquo;ve decided to give Nix a try. I&rsquo;m using Nix everywhere at this point - it handles my <a href="https://github.com/nxy7/dotfiles">PC configuration</a>,
it handles my project dependencies, and I&rsquo;m sure it will be able to build my images!</p>
<p>In hindsight the easiest way to do it would be using Skopeo
(which I&rsquo;ve actually ended up using in my nix solution) to push images built by docker, but issues mentioned above gave me a push to explore other possibilities
and let me tell you - I don&rsquo;t regret it.</p>
<h1 id="why-would-i-use-nix-instead-of-docker">Why would I use Nix instead of Docker?!<a hidden class="anchor" aria-hidden="true" href="#why-would-i-use-nix-instead-of-docker">#</a></h1>
<h3 id="same-dev-and-prod-dependency-versions">Same dev and prod dependency versions<a hidden class="anchor" aria-hidden="true" href="#same-dev-and-prod-dependency-versions">#</a></h3>
<p>Nix is ecosystem that greatly benefits from You using it in many places. If You&rsquo;re using Nix to manage project dependencies, then chances are that some of them will be required in final docker image. With Nix you can be sure that dependencies You&rsquo;re using locally are the same dependencies that will be contained within your final docker image.</p>
<h3 id="smaller-images">Smaller images<a hidden class="anchor" aria-hidden="true" href="#smaller-images">#</a></h3>
<p>With Nix it&rsquo;s also really easy to make sure You don&rsquo;t end up putting too much junk inside your images. That&rsquo;s the advantage of declarative configuration - we specify what is needed and nix takes care of it for us. This way imperative commands like <code>apt update</code> will not accidentally pollute our containers. It&rsquo;s not a guarantee however and depends on the &lsquo;quality&rsquo; of packages you decide to include. Some packages may still include things that are not necessary, but it&rsquo;s much easier to track them down - just look into .nix source of pkgs you import.</p>
<h3 id="reuse-container-image-creation-logic">Reuse container image creation logic<a hidden class="anchor" aria-hidden="true" href="#reuse-container-image-creation-logic">#</a></h3>
<p>Nix also makes reusing code for multiple docker images much easier. Let me show you one example. One of the projects I&rsquo;m developing is made using rust. It produces few binaries
each from separate workspace member. My build phase looks like this <code>buildPhase = &quot;cargo build --release --bin ${name}</code>, so the only variable in whole Dockerfile would be binary name.
To reuse logic responsible for building those images I&rsquo;ve made separate <code>buildPackage.nix</code> file:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span>{ pkgs <span style="color:#f92672">?</span> <span style="color:#f92672">import</span> <span style="color:#e6db74">&lt;nixpkgs&gt;</span> { }<span style="color:#f92672">,</span> path <span style="color:#f92672">?</span> <span style="color:#e6db74">./.</span> }:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span>
</span></span><span style="display:flex;"><span>  cargoFile <span style="color:#f92672">=</span> (builtins<span style="color:#f92672">.</span>fromTOML (builtins<span style="color:#f92672">.</span>readFile <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>path<span style="color:#e6db74">}</span><span style="color:#e6db74">/Cargo.toml&#34;</span>));
</span></span><span style="display:flex;"><span>  name <span style="color:#f92672">=</span> cargoFile<span style="color:#f92672">.</span>package<span style="color:#f92672">.</span>name;
</span></span><span style="display:flex;"><span>  version <span style="color:#f92672">=</span> cargoFile<span style="color:#f92672">.</span>package<span style="color:#f92672">.</span>version;
</span></span><span style="display:flex;"><span>  buildRustPackage <span style="color:#f92672">=</span> (pkgs<span style="color:#f92672">.</span>makeRustPlatform {
</span></span><span style="display:flex;"><span>    cargo <span style="color:#f92672">=</span> pkgs<span style="color:#f92672">.</span>cargo;
</span></span><span style="display:flex;"><span>    rustc <span style="color:#f92672">=</span> pkgs<span style="color:#f92672">.</span>rustc;
</span></span><span style="display:flex;"><span>  })<span style="color:#f92672">.</span>buildRustPackage;
</span></span><span style="display:flex;"><span>  dockerTools <span style="color:#f92672">=</span> pkgs<span style="color:#f92672">.</span>dockerTools;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">in</span> <span style="color:#66d9ef">rec</span> {
</span></span><span style="display:flex;"><span>  app <span style="color:#f92672">=</span> buildRustPackage {
</span></span><span style="display:flex;"><span>    pname <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>    version <span style="color:#f92672">=</span> version;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    src <span style="color:#f92672">=</span> <span style="color:#e6db74">./.</span>;
</span></span><span style="display:flex;"><span>    buildAndTestSubdir <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    nativeBuildInputs <span style="color:#f92672">=</span> <span style="color:#66d9ef">with</span> pkgs; [ pkg-config ];
</span></span><span style="display:flex;"><span>    buildInputs <span style="color:#f92672">=</span> <span style="color:#66d9ef">with</span> pkgs; [ openssl ];
</span></span><span style="display:flex;"><span>    PKG_CONFIG_PATH <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>pkgs<span style="color:#f92672">.</span>openssl<span style="color:#f92672">.</span>dev<span style="color:#e6db74">}</span><span style="color:#e6db74">/lib/pkgconfig&#34;</span>;
</span></span><span style="display:flex;"><span>    buildPhase <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cargo build --release --bin </span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>;
</span></span><span style="display:flex;"><span>    installPhase <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      mkdir -p $out/bin
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">      cp target/release/</span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74"> $out/bin/
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#39;&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    cargoLock <span style="color:#f92672">=</span> { lockFile <span style="color:#f92672">=</span> <span style="color:#e6db74">./Cargo.lock</span>; };
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>  buildImage <span style="color:#f92672">=</span> dockerTools<span style="color:#f92672">.</span>buildImage {
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> name;
</span></span><span style="display:flex;"><span>    tag <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;latest&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    copyToRoot <span style="color:#f92672">=</span> pkgs<span style="color:#f92672">.</span>buildEnv {
</span></span><span style="display:flex;"><span>      name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;image-root&#34;</span>;
</span></span><span style="display:flex;"><span>      paths <span style="color:#f92672">=</span> [ app pkgs<span style="color:#f92672">.</span>busybox pkgs<span style="color:#f92672">.</span>libtree ];
</span></span><span style="display:flex;"><span>      pathsToLink <span style="color:#f92672">=</span> [ <span style="color:#e6db74">&#34;/bin&#34;</span> ];
</span></span><span style="display:flex;"><span>    };
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    config<span style="color:#f92672">.</span>Entrypoint <span style="color:#f92672">=</span> [ <span style="color:#e6db74">&#34;/bin/</span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span> ];
</span></span><span style="display:flex;"><span>    config<span style="color:#f92672">.</span>Env <span style="color:#f92672">=</span> [ <span style="color:#e6db74">&#34;SSL_CERT_FILE=</span><span style="color:#e6db74">${</span>pkgs<span style="color:#f92672">.</span>cacert<span style="color:#e6db74">}</span><span style="color:#e6db74">/etc/ssl/certs/ca-bundle.crt&#34;</span> ];
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>It&rsquo;s just a nix function! Now in my <code>backend/default.nix</code> I can easily build several rust binaries using the same &lsquo;dockerfile&rsquo;.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> buildPackage <span style="color:#f92672">=</span> <span style="color:#f92672">import</span> <span style="color:#e6db74">./buildPackage.nix</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">in</span> {
</span></span><span style="display:flex;"><span>  serviceA <span style="color:#f92672">=</span> buildPackage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inherit</span> pkgs;
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">./serviceA</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  serviceB <span style="color:#f92672">=</span> buildPackage {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">inherit</span> pkgs;
</span></span><span style="display:flex;"><span>    path <span style="color:#f92672">=</span> <span style="color:#e6db74">./serviceB</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="build-and-push-images-with-one-command">Build and push images with one command<a hidden class="anchor" aria-hidden="true" href="#build-and-push-images-with-one-command">#</a></h3>
<p>I admit, anything can be done in one command with shell scripts, but Nix gives us much stronger guarantees about correctness of our
logic and I personally feel much more confident about using Nix instead of equivalent shell scripts. Anyway I&rsquo;ve shown how I build my rust images
in previous step, now let&rsquo;s make Nix push the image for us.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nix" data-lang="nix"><span style="display:flex;"><span><span style="color:#75715e"># reusable &#39;push&#39; function that accepts docker image, name and optional tag</span>
</span></span><span style="display:flex;"><span>pushImage <span style="color:#960050;background-color:#1e0010">=</span> { imageTar<span style="color:#f92672">,</span> name<span style="color:#f92672">,</span> tag <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;latest&#34;</span> }:
</span></span><span style="display:flex;"><span>  pkgs<span style="color:#f92672">.</span>writeShellScriptBin <span style="color:#e6db74">&#34;push-script&#34;</span> <span style="color:#e6db74">&#39;&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    </span><span style="color:#e6db74">${</span>pkgs<span style="color:#f92672">.</span>skopeo<span style="color:#e6db74">}</span><span style="color:#e6db74">/bin/skopeo copy docker-archive:</span><span style="color:#e6db74">${</span>imageTar<span style="color:#e6db74">}</span><span style="color:#e6db74"> docker://</span><span style="color:#e6db74">${</span>yourImageRegistry<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>projectName<span style="color:#e6db74">}</span><span style="color:#e6db74">/</span><span style="color:#e6db74">${</span>name<span style="color:#e6db74">}</span><span style="color:#e6db74">:</span><span style="color:#e6db74">${</span>tag<span style="color:#e6db74">}</span><span style="color:#e6db74"> --dest-tls-verify=false
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">  &#39;&#39;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># in output of flake</span>
</span></span><span style="display:flex;"><span>packages <span style="color:#960050;background-color:#1e0010">=</span> {
</span></span><span style="display:flex;"><span>  serviceA <span style="color:#f92672">=</span> pushImage {
</span></span><span style="display:flex;"><span>    imageTar <span style="color:#f92672">=</span> serviceA<span style="color:#f92672">.</span>buildImage;
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;serviceA&#34;</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>  serviceB <span style="color:#f92672">=</span> pushImage {
</span></span><span style="display:flex;"><span>    imageTar <span style="color:#f92672">=</span> serviceB<span style="color:#f92672">.</span>buildImage;
</span></span><span style="display:flex;"><span>    name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;serviceB&#34;</span>;
</span></span><span style="display:flex;"><span>  };
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Now to build and push image we run <code>nix run .#serviceA</code>. As You can probably tell I&rsquo;m actually using skopeo to push the final image and IMAO
one liner visible in pushImage function is great example of why Nix is so great. If I&rsquo;d want to make shell script with equivalent functionality it would be
necessary to make script that validates arguments given to it from CLI, then you&rsquo;d need to make sure <code>skopeo</code> is installed (or worse - install it imperatively)
and only then You&rsquo;d be able to copy the image. Using Nix for this task it&rsquo;s trivial. There&rsquo;s no need to think about any of those things. You can just run anything
packaged for Nix as if it was already installed.</p>
<h3 id="nix-is-the-best-abstraction-for-building-environments">Nix is the best abstraction for building environments<a hidden class="anchor" aria-hidden="true" href="#nix-is-the-best-abstraction-for-building-environments">#</a></h3>
<p>Think about your docker container. What&rsquo;s it purpose? It isolates network and runtime dependencies from your system. That&rsquo;s what allows you to select which version
of postgres you want to run easily. Even if they are used to making reproducible environments, it&rsquo;s not the best tool for the job - f.e. they lack version locking mechanism.
It can be used for this task, because as I mentioned it isolates runtime dependencies, but it&rsquo;s side effect and not something baked into containers design.
When we ship software we really need both - reproducible environment that can satisfy our runtime needs and runtime isolated from the underlying system.
Nix + Docker combination gives us both, which is why I think using Nix to build images is great idea.</p>
<h1 id="what-next">What next<a hidden class="anchor" aria-hidden="true" href="#what-next">#</a></h1>
<p>Chances are You liked this short showcase of Nix, but still don&rsquo;t know how to use it Yourself. Nix learning curve is pretty hard after all. If you want to build images using Nix, but aren&rsquo;t very proficient in using the language I suggest the following learning path. First - package your software using Nix. In many cases it&rsquo;ll boil down to using appropriate builder (like buildRustPackage in examples above, but there are similar functions for other languages as well), but sometimes it can be much harder, especially if Your project depends on software not available in nixpkgs.
When your app is packaged correctly look into <code>dockerTools.buildImage</code> documentation. It&rsquo;s rather simple to use, but if You have any questions about it feel free to ask in the comments. I sincerely think that the best way to learn nix is by actively using it. No amount of reading helps as much as just porting some Dockerfiles to flake.nix files, so experiment and have fun :-)</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><div id="disqus_thread"></div>
<script type="application/javascript">
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "nxyt" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://nxyt.pl/blog">just some developer thoughts</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
